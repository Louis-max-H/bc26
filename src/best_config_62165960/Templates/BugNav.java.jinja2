//  Destination: Utils/BugNavLmx.java

{# Scores pour franchir une cellule#}
{% set SCORE_CELL_PASSABLE  =    200 %}
{% set SCORE_CELL_IF_DIG    =    220 %}
{% set SCORE_CELL_WALL      =  32000 %}

{# Parametres pour la génération du code #}
{% set DEBUG = false %}
{% set BATTLECODE = true %}
{% set MAX_DEBUG_ROUND = 150 %}
{% set DOT_DEBUG_LEVEL = 0%} {# Level of debug for battlecode0: None, 1: Only backtraking, 2: All #}

{# Fonctions utilitaires #}
{% set getRound = "rc.getRoundNum()" if BATTLECODE else "0" %}
{% macro impossible(MSG) -%}throw new java.lang.Error("ERR Pathfinding: {{MSG}}");{%- endmacro %}

{# Imports #}
{% if BATTLECODE %}
package best_config_62165960.Utils;
import battlecode.common.*;
import best_config_62165960.Robots.Robot;

{% else -%}
package Bugnav;
import Bugnav.MapLocation;
import Bugnav.Direction;
{% endif -%}

//@formatter:off

{# Directions #}
{% set dirs = ["NORTH","NORTHEAST","EAST","SOUTHEAST","SOUTH","SOUTHWEST","WEST","NORTHWEST"] %}
{% set dirsPriority = {
        'NORTH': ['NORTH', 'NORTHEAST', 'NORTHWEST', 'EAST', 'WEST', 'SOUTH', 'SOUTHEAST', 'SOUTHWEST'],
        'NORTHEAST': ['NORTHEAST', 'EAST', 'NORTH', 'NORTHWEST', 'SOUTHEAST', 'SOUTH', 'WEST', 'SOUTHWEST'],
        'EAST': ['EAST', 'NORTHEAST', 'SOUTHEAST', 'NORTH', 'SOUTH', 'WEST', 'NORTHWEST', 'SOUTHWEST'],
        'SOUTHEAST': ['SOUTHEAST', 'EAST', 'SOUTH', 'NORTHEAST', 'SOUTHWEST', 'NORTH', 'WEST', 'NORTHWEST'],
        'SOUTH': ['SOUTH', 'SOUTHEAST', 'SOUTHWEST', 'EAST', 'WEST', 'NORTH', 'NORTHEAST', 'NORTHWEST'],
        'SOUTHWEST': ['SOUTHWEST', 'SOUTH', 'WEST', 'NORTHWEST', 'SOUTHEAST', 'EAST', 'NORTH', 'NORTHEAST'],
        'WEST': ['WEST', 'WEST', 'NORTHWEST', 'SOUTHWEST', 'NORTH', 'SOUTH', 'EAST', 'NORTHEAST', 'SOUTHEAST'],
        'NORTHWEST': ['NORTHWEST', 'NORTH', 'WEST', 'NORTHEAST', 'SOUTHWEST', 'EAST', 'SOUTH', 'SOUTHEAST']
    }
%}




public class {{ className }} {
    public static int width = 60;
    public static int height = 60;
    public static int SCORE_CELL_WALL = {{ SCORE_CELL_WALL }}; // Should not exceed 8 bits int (If added to anything else, to not overflow)
    public static int SCORE_CELL_IF_DIG = {{ SCORE_CELL_IF_DIG }};
    public static int SCORE_CELL_PASSABLE = {{ SCORE_CELL_PASSABLE }};

    public static void init(int width, int height){
        {{ className }}.width = width;
        {{ className }}.height = height;
    }

    public static boolean onTheMap(MapLocation loc){
        return loc.x >= 0 && loc.x < width && loc.y >= 0 && loc.y < height;
    }

    // Attributs for caching
    public static int timeBeforeRefresh = 0;
    public static MapLocation lastDestination;

    // Used for backtracking
    public static int resultCode = 0; // 1 : Ok, -1: Not enought bytecode
    public static String mode = "DEFAULT";
    public static int xyLastWallHit = -1;
    public static int xyLastWallLeave = -1;

    // Used for pathfinding
    public static char[] mapResult;
    public static char[] mapCosts = generateEmptyMapCosts();


    // Convert direction (char value) at index startXY to Direction enum
    public static Direction getResult(int startXY){
        return switch(mapResult[startXY]){
            {% for dir in dirs%}
            case {{dirsOrds[dir]}} -> Direction.{{dir}};
            {% endfor %}

            default -> {
               {% if BATTLECODE -%}RobotController rc = Robot.rc;{% endif -%}
                if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                    System.out.println("Unknow direction return from Pathfinding : " + (int)mapResult[startXY]);
                }
                yield Direction.CENTER;
            }
        };
    }


    // Wrapper for pathfinding with less parameters
    public static Direction pathTo(
        MapLocation startLoc, MapLocation endLoc,
        char[] mapCosts, int MAX_SCORE, int cost_max_per_cell, int maxBytecodeUsed
    ){% if BATTLECODE %} throws GameActionException {% endif -%} {
        

        // Check if cost_max_per_cell is greater than SCORE_CELL_WALL
        if(cost_max_per_cell > {{SCORE_CELL_WALL}}){
            {{ impossible(MSG="cost_max_per_cell is greater than SCORE_CELL_WALL {{SCORE_CELL_WALL}}") }}
        }

        int startXY = startLoc.x + 60*startLoc.y;

        {% if BATTLECODE -%}RobotController rc = Robot.rc;{% endif -%}
        if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
            System.out.println("Start Pathfinding from " + startLoc + " to " + endLoc);
        }
        
        // Check if we can reuse previous path
        Direction dir;
        if(mapCosts == null){mapCosts = {{ className }}.mapCosts;}
        if(timeBeforeRefresh > 0 && lastDestination.equals(endLoc)){
            dir = getResult(startXY);
            if(dir != Direction.CENTER){
                System.out.println("Pathfinding: Reuse previous path -> " + dir);
                timeBeforeRefresh -= 3;
                return dir;
            }
        }

        // Generate path
        mode = "DEFAULT";
        resultCode = generatePathTo(startLoc, endLoc, mapCosts, getMap3600(), MAX_SCORE, true, cost_max_per_cell, maxBytecodeUsed);
        
        // Check result validity
        dir = getResult(startXY);
        if(resultCode < 0){
            if({{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                System.out.println("Pathfinding: Warning return code : " + resultCode + " : " + dir);
            }    
            timeBeforeRefresh = 0; // Don't save query result
            
        }else{
            if({{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                System.out.println("Pathfinding: SUCCESS -> " + dir);
            }
            timeBeforeRefresh = 3; // Save query result for 3 rounds
            lastDestination = endLoc;
        }
        return dir;
    }


    private static int generatePathTo(
        MapLocation startLoc, MapLocation endLoc, 
        char[] mapCosts, char[] mapResult,
        int MAX_SCORE, boolean withReturn, 
        int cost_max_per_cell, int maxBytecodeUsed){% if BATTLECODE %} throws GameActionException {% endif -%}{

        {% if BATTLECODE -%}RobotController rc = Robot.rc;{% endif -%}

        // Initialize variables
        int xy = startLoc.x + 60*startLoc.y;
        int xyEnd = endLoc.x + 60*endLoc.y;
        int xyTmp;
        int xyLeft = -1;
        int xyRight = -1;
        int ctrRight = 0;
        int ctrLeft = 0;
        int smoothLeft;
        int smoothRight;
        mapResult[xy] = {{dirsOrdsOpposite["CENTER"]}};
        MapLocation loc = new MapLocation(startLoc.x, startLoc.y);
        MapLocation locEnd = new MapLocation(endLoc.x, endLoc.y);


        // Initialize result variables
        int score = 0;
        xyLastWallHit = -1;
        xyLastWallLeave = -1;
        MapLocation locLeft = null;
        MapLocation locRight = null;


        // Bytecode and benchmark variables
        int iterationsSplit = 0;
        int iterationsNormal = 0;
        int startRemainingBytecode = {% if BATTLECODE %} Clock.getBytecodesLeft() {% else %} 0 {% endif -%};
        int stopBellowBytecodeRemaining;
        if(withReturn){
            stopBellowBytecodeRemaining = {% if BATTLECODE %} Clock.getBytecodesLeft() - maxBytecodeUsed / 3 {% else %} 0 {% endif -%};
        }else{
            stopBellowBytecodeRemaining = {% if BATTLECODE %} Clock.getBytecodesLeft() - maxBytecodeUsed {% else %} 0 {% endif -%};
        }
        {% set getBytecodeRemaining = "Clock.getBytecodesLeft()" if BATTLECODE else "1" %}



        mainLoop: // We exit the loop when direction to target is Direction.CENTER
        for(;;) {

            /////////////////////////////////// Default mode ////////////////////////////////
            /// we just go to the direction. If wall, we check if better left or right and enter left or right mode then
            modeDefault:
            for (;;) {
                iterationsNormal++;

                {# Debug messages #}
                {% if DEBUG -%}
                    System.out.println("MODE=" + mode + ", resume at POS=" + xy + " " + loc + " want to go to " + locEnd + " -> " + loc.directionTo(locEnd));
                    if(withReturn){System.out.println("SCORE=" + score);}
                {% endif -%}
                {% if BATTLECODE and DOT_DEBUG_LEVEL >= 2 -%}
                    if(withReturn){  rc.setIndicatorDot(loc, 0, 10, 10); // Blue
                    }else{           rc.setIndicatorDot(loc, 206, 174, 243); // Violet
                    }
                {% endif -%}

                {# Check if we have enough bytecode remaining #}
                if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                    {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                    {% endif -%}
                    break mainLoop;
                }

                {# Check direction to target #}
                switch (loc.directionTo(locEnd)) {
                    {% for dir in dirs -%}
                    case {{dir}}:

                        {# Check if direction is on the map #}
                        if(!onTheMap(loc.add(Direction.{{dir}}))){
                            {{ impossible(MSG="Reach a border when direction to cell on map") }}
                        }

                        {# Check if we can move to this cell #}
                        xyTmp = xy + {{dirsShift60xy[dir]}};
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            {% if DEBUG -%}System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=WALL");
                            {% endif -%}

                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                        {# Move to this direction #}
                        {% if DEBUG -%}System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=OK score: " + (int)mapCosts[xyTmp]);
                        {% endif -%}
                        xy = xyTmp;
                        loc = loc.add(Direction.{{dir}});
                        mapResult[xyTmp] = {{dirsOrdsOpposite[dir]}};
                        break;
                    {%endfor %}

                    {# If direction to target is center, we have reached our destination #}
                    case CENTER:
                        {% if DEBUG -%}System.out.println("MSG=CENTER");
                        {% endif -%}
                        break mainLoop;
                }
        
                {# We are on the next cell, update score #}
                score += mapCosts[xy];
                if(score >= MAX_SCORE){ // We haven't enough score to reach our destination
                    {% if DEBUG -%}System.out.println("MSG=MAX_SCORE " + score + " >= " + MAX_SCORE);
                    {% endif -%}
                    break mainLoop;
                }
            }


            /// ///////////////////// Init split mode /////////////////////
            {% if DEBUG -%}System.out.println("MSG=init split mode");
            {% endif -%}

            {# Initialize split mode variables #}
            xyLeft = xy;
            xyRight = xy;
            locLeft = null;
            locRight= null;
            smoothLeft = 2;
            smoothRight = 2;
            int scoreLeft = 0;
            int scoreRight = 0;
            Direction lastDirectionLeft = Direction.CENTER;
            Direction lastDirectionRight = Direction.CENTER;

            // loc.directionTo(locEnd) is an obstacle, we need to init left and right side for exploration
            switch (loc.directionTo(locEnd)) {

                {% for dir in dirs -%}
                case {{dir}}:
                
                    {% for side in ["Left", "Right"] -%}

                    initSide{{side}}:{
                    {% for i in range(1, 7) -%}
                    {% set dirTest = rotate(dir, side, i) -%} {# Test a direction by progressively turning, we stop when we find a cell that is not a wall #}
                    if(onTheMap(loc.add(Direction.{{dirTest}})) && mapCosts[xy + {{dirsShift60xy[dirTest]}}] <= cost_max_per_cell) {
                        {# We found a cell that is not a wall, we can init the side #}
                        ctr{{side}} = {{i}};
                        loc{{side}} = loc.add(Direction.{{dirTest}});
                        xy{{side}} = xy + {{dirsShift60xy[dirTest]}};
                        lastDirection{{side}} = Direction.{{dirTest}};
                        mapResult[xy{{side}}] = {{dirsOrdsOpposite[dirTest]}};

                        {# Debug messages #}
                        {% if DEBUG -%}
                            System.out.println("POS=" + xy + ", DIR={{dirTest}}, RESULT=OK");
                            System.out.println("MSG={{side}} init to " + xy{{side}});
                        {% endif -%}
                        break initSide{{side}};

                    }
                    {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy + ", DIR={{dirTest}}, RESULT=WALL");
                    {% endif -%}

                    {% endfor -%} {# for i in range(1, 7) #}

                    {{ impossible(MSG="impossible to init split mode (All directions are blocked)") }}
                    } // End initSide{{side}}
                    {% endfor %} {# for side in ["Left", "Right"] #}
                    break;

                {% endfor %}     {# for dir in dirs #}

                default:
                    {{ impossible(MSG="dir is center when split init") }}
            }

            
            // TODO: Add default score for left / right depending situation
            scoreLeft = score + mapCosts[xyLeft];
            scoreRight = score + mapCosts[xyRight];

            /////////////////////////////////// Split mode ////////////////////////////////
            /// The direction we want to take is blocked, we will split bugnav to right and left
            /// We advance side with the lowest score, with score = distance for example
            /// When dir is not blocked anymore, we go back to modeDefault

            modeSplit:
            for (;;) {
                iterationsSplit++;
                if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                    {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                    {% endif -%}
                    break mainLoop;
                }

                if(scoreLeft < scoreRight + SCORE_CELL_PASSABLE * 4){ // Little advantage on right
                    if(scoreLeft >= MAX_SCORE){
                        {% if DEBUG -%}System.out.println("MSG=MAX_SCORE left " + scoreLeft + " and right " + scoreRight + " are >= " + MAX_SCORE);
                        {% endif -%}

                        break mainLoop;
                    }

                    {% for side in ["Left", "Right"] %}
                    {% if DEBUG -%}
                    System.out.println("MSG={{ side }}, MODE={{ side }}, score " + score + " resume at POS=" + xy{{side}} + " last dir " + lastDirection{{side}} + " ctr{{side}}=" + ctr{{side}});
                    if(withReturn){System.out.println("SCORE{{side}}=" + score{{side}});}
                    {% endif -%}

                    
                    modeSplitGo{{side}}: {
                    /// If we can move without obstacle, we are free !
                    {% if DEBUG -%}System.out.println("We want to go from " + loc{{side}} + " to " + locEnd + " -> " + loc{{side}}.directionTo(locEnd));
                    {% endif -%}
                    {% if BATTLECODE and DOT_DEBUG_LEVEL >= 2 %}
                    {% if side == "Left" %}
                        rc.setIndicatorDot(loc{{side}}, 255, 228, 181);
                    {% else %}
                        rc.setIndicatorDot(loc{{side}}, 173, 216, 230);
                    {% endif -%}
                    {% endif%}
                    if(ctr{{side}} <= 0){ {# Avoid cycling same direction #}
                        switch (loc{{side}}.directionTo(locEnd)){
                            {% for dir in dirs -%}
                            case {{ dir }}:
                                xyTmp = xy{{side}} + {{dirsShift60xy[dir]}};
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smooth{{side}} <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = {{dirsOrdsOpposite[dir]}};
                                    xyLastWallLeave = xyTmp;
                                    {% if DEBUG -%}System.out.println("MODE=FREE, POS=" + xy + ", DIR={{dir}}, RESULT=FREE");
                                    {% endif -%}

                                    loc = loc{{side}}.add(Direction.{{dir}});
                                    score = score{{side}} + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            {% endfor %}

                            case CENTER:
                                {% if DEBUG -%}System.out.println("MSG=Destination reached for side {{side}}");
                                {% endif -%}

                                break mainLoop;
                        }
                    }

                    //TODO: Ces 2 la peuvent se grouper ?
                    /// Otherwise, we check by turning progressively until we found a nice space
                    switch (lastDirection{{side}}){
                        {% for dir in dirs -%}
                        case {{ dir }}:
                            {% for i in range(-2, 6)-%}
                            {% set dirTesting = rotate(dir, side, i) -%}
                            if(!onTheMap(loc{{side}}.add(Direction.{{dirTesting}}))) {
                                {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy + ", DIR={{dirTesting}}, RESULT=BORDER");
                                {% endif -%}

                                score{{side}} = MAX_SCORE;
                                break modeSplitGo{{side}};
                            }

                            xyTmp = xy{{side}} + {{dirsShift60xy[dirTesting]}};
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy{{side}} + ", DIR={{dirTesting}}, RESULT=OK");
                                {% endif -%}


                                xy{{side}} = xyTmp;
                                ctr{{side}} += {{i}};
                                mapResult[xyTmp] = {{dirsOrdsOpposite[dirTesting]}};

                                loc{{side}} = loc{{side}}.add(Direction.{{dirTesting}});
                                score{{side}} += mapCosts[xyTmp];
                                lastDirection{{side}} = Direction.{{ dirTesting }};
                                break modeSplitGo{{side}};
                            }
                            {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy{{side}} + ", DIR={{dirTesting}}, RESULT=WALL");
                            {% endif -%}

                            {% endfor -%}

                            {{ impossible(MSG="Can't find solution for side " + side + " and previous dir " + dir) }}
                        {% endfor %}

                        case CENTER:
                            {{ impossible(MSG="previous dir is center") }}
                    }
                    } // End modeSplitGo{{side}}

                    {# for side #}
                    {% if side == "Left" %}
                }else{
                    {% if DEBUG -%}System.out.println("MSG=scoreLeft >= scoreRight");
                    {% endif -%}

                    
                            {% endif -%}


                    {# Will generate the code for right here #}
                    {% endfor %}
                }

            }// End main for loop
        } // End mainLoopLabel

        if(!withReturn){
            if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                System.out.println("===Pathfinding report : Backtracking===");
                System.out.println("Iterations normal : " + iterationsNormal);
                System.out.println("Iterations split  : " + iterationsSplit);
                System.out.println("Bytecode used     : " + (startRemainingBytecode - {{getBytecodeRemaining}}));
            }

            {% if DEBUG -%}System.out.println("MSG=no return");
            {% endif -%}

            {{ className }}.mapResult = mapResult;
            if(xy != xyEnd){
                return -1;
            }
            return 1;
        }

        {% if DEBUG -%}System.out.println("Return mode");
        {% endif -%}

        /// Now, we want to make the path in reverse to optimize it
        // We take by priority :
        // 1) xyLastWallLeave
        // 2) Best beetween xyLeft and xyRight
        // 3) xy

        int xyReturn;
        if(xyLastWallLeave != -1){
            xyReturn = xyLastWallLeave; // 1)
            {% if DEBUG -%}System.out.println("POS=" + xy + ", RESULT=RETURN = last wall leave");
            {% endif -%}

        }else{
            {% if DEBUG -%}System.out.println("xyLastWallLeave is " + xyLastWallLeave + " trying other values for xyReturn");
            {% endif -%}
            if(locLeft == null){
                {% if DEBUG -%}System.out.println("locLeft is null, returning xyRight");
                {% endif -%}
                xyReturn = xyRight;

            }else{
                if(locRight == null){
                    {% if DEBUG -%}System.out.println("locRight is null, returning xyLeft");
                    {% endif -%}
                    xyReturn = xyLeft;

                }else{
                    if(locEnd.distanceSquaredTo(locLeft) < locEnd.distanceSquaredTo(locRight)){ // 2)
                        xyReturn = xyLeft;
                        {% if DEBUG -%}System.out.println("locLeft is closer to end, returning xyLeft");
                        {% endif -%}


                    }else{
                        xyReturn = xyRight;
                        {% if DEBUG -%}System.out.println("locRight is closer to end, returning xyRight");
                        {% endif -%}
                    }
                }
            }

            // 3)
            if(xyReturn == -1){
                {% if DEBUG -%}System.out.println("xyReturn is -1, returning xy");
                {% endif -%}

                xyReturn = xy;
            }

        }

        if(xyReturn == -1){
            {{ impossible(MSG="xyReturn is -1") }}
        }

        loc = new MapLocation(xyReturn % 60, xyReturn / 60);
        mode = "BACK";
        int returnDirection = mapResult[xyReturn];
        int iterationsReturn = 0;
        backtrackingLoop:
        for(;;){
            iterationsReturn++;
            if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                {% endif -%}
                break backtrackingLoop;
            }

            {% if BATTLECODE and DOT_DEBUG_LEVEL >= 1 %}
            rc.setIndicatorDot(loc, 206, 174, 243);
            {% endif -%}


            {% if DEBUG -%}System.out.println("MODE=BACK, I am at: POS=" + xyReturn + " " + loc +", returnDirection is " + returnDirection);
            {% endif -%}

            {# Check if the outward path diverges from the return path -#}
            switch(loc.directionTo(startLoc)){
                {% for dir in dirs -%}
                case {{dir}}:
                    if({{dirsOrds[dir]}} != returnDirection && mapCosts[xyReturn + {{dirsShift60xy[dir]}}] <= cost_max_per_cell){
                        {% if DEBUG -%}System.out.println("MODE=BACK, POS=" + xyReturn + ", DIR={{dir}}, RESULT=DIVERGE from return path");
                        {% endif -%}
                        loc = loc.add(Direction.{{dir}});     
                        break backtrackingLoop;
                    }else{
                        {% if DEBUG -%}System.out.println("MODE=BACK, POS=" + xyReturn + ", DIR={{dir}}, RESULT=WALL");
                        {% endif -%}
                    }
                    break;
                {% endfor %}

                case CENTER:
                    {% if DEBUG -%}System.out.println("MSG=Destination reached");
                    {% endif -%}
                    {{ className }}.mapResult = mapResult;
                    return 1;
            }

            {# Go up one move -#}
            switch(returnDirection){
                {% for dir in dirs -%}
                case {{dirsOrds[dir]}}: // {{dir}}
                    {% if DEBUG -%}System.out.println("MODE=BACK, POS=" + xyReturn + " " + loc +", DIR={{dir}}");
                    {% endif -%}

                    xyReturn += {{dirsShift60xy[dir]}};
                    loc = loc.add(Direction.{{dir}});
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = {{dirsOrdsOpposite[dir]}};
                    break;
                {% endfor %}
            }
        }// End backtrackingLoop

        if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
            System.out.println("===Pathfinding report : Normal===");
            System.out.println("Iterations normal : " + iterationsNormal);
            System.out.println("Iterations split  : " + iterationsSplit);
            System.out.println("Iterations return : " + iterationsReturn);
            System.out.println("Bytecode used     : " + (startRemainingBytecode - {{getBytecodeRemaining}}));
            System.out.println("");
        }

        return generatePathTo(
            loc, startLoc, 
            mapCosts, mapResult, MAX_SCORE, {#With return#} false, 
            cost_max_per_cell, maxBytecodeUsed
        );
    }

    public static char[] generateEmptyMapCosts(){
        return "{%for y in range(60)-%}{% for x in range(60)-%}{%if x % 2 == 0 and y % 2 == 0%}{{intToChar(SCORE_CELL_PASSABLE)}}{%else%}{{intToChar(SCORE_CELL_PASSABLE)}}{%endif%}{%endfor%}{%endfor%}".toCharArray();
    }

    public static char[] getMap3600(){
        return "{%for x in range(3600)%}\u0000{%endfor%}".toCharArray();
    }
}
