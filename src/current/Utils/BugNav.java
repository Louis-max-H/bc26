// #########################################################
// !!!!!!!!!! This file is generated by jinja.py !!!!!!!!!!!
// !!!! Dont edit it manually, check in template folder !!!!
// #########################################################

//  Destination: Utils/BugNav.java


package current.Utils;
import battlecode.common.*;
import current.Robots.Robot;

//@formatter:off





// encode(x, y) = (x+1) + (y + 1)(1 + 60 + 1) = x + 60*y
public class BugNav {
    public static int width = 60;
    public static int height = 60;

    public static int SCORE_CELL_PASSABLE = 200;
    public static int SCORE_CELL_IF_DIG = 220;
    public static int SCORE_CELL_WALL = 32000; // Should not exceed 8 bits int (If added to anything else, to not overflow)

    public static void init(int width, int height){
        BugNav.width = width;
        BugNav.height = height;
    }

    public static boolean onTheMap(MapLocation loc){
        return loc.x >= 0 && loc.x < width && loc.y >= 0 && loc.y < height;
    }

    public static int xyLastWallHit = -1;
    public static int xyLastWallLeave = -1;
    public static char[] mapResult;
    public static String mode = "DEFAULT";
    public static char[] mapCosts = generateEmptyMapCosts();

    public static void pathTo(
        MapLocation startLoc, MapLocation endLoc,
        char[] mapCosts, int MAX_SCORE, int cost_max_per_cell, int maxBytecodeUsed
    ){
        if(cost_max_per_cell > 32000){
            throw new java.lang.Error("ERR Pathfinding: cost_max_per_cell is greater than SCORE_CELL_WALL {{SCORE_CELL_WALL}}");
        }
        mode = "DEFAULT";
        generatePathTo(startLoc, endLoc, mapCosts, getMap3600(), MAX_SCORE, true, cost_max_per_cell, maxBytecodeUsed);
    }

    public static void generatePathTo(
        MapLocation startLoc, MapLocation endLoc, 
        char[] mapCosts, char[] mapResult,
        int MAX_SCORE, boolean withReturn, 
        int cost_max_per_cell, int maxBytecodeUsed){

        RobotController rc = Robot.rc;
        
        if(mapCosts == null){
            mapCosts = BugNav.mapCosts;
        }
        int xy = startLoc.x + 60*startLoc.y;
        int xyTmp;
        int xyLeft = -1;
        int xyRight = -1;
        int ctrRight = 0;
        int ctrLeft = 0;
        int smoothLeft;
        int smoothRight;


        int score = 0;
        xyLastWallHit = -1;
        xyLastWallLeave = -1;
        MapLocation locLeft = null;
        MapLocation locRight = null;

        // Bytecode and stats
        int iterationsSplit = 0;
        int iterationsNormal = 0;
        int startRemainingBytecode =  Clock.getBytecodesLeft() ;
        int stopBellowBytecodeRemaining;
        if(withReturn){
            stopBellowBytecodeRemaining =  Clock.getBytecodesLeft() - maxBytecodeUsed / 2 ;
        }else{
            stopBellowBytecodeRemaining =  Clock.getBytecodesLeft() - maxBytecodeUsed ;
        }
        
        MapLocation loc = new MapLocation(startLoc.x, startLoc.y);
        MapLocation locEnd = new MapLocation(endLoc.x, endLoc.y);
                mapResult[xy] = 8;


        mainLoop: // We exit the loop when direction to target is Direction.CENTER
        for(;;) {

            /////////////////////////////////// Default mode ////////////////////////////////
            /// we just go to the direction. If wall, we check if better left or right and enter left or right mode then
            modeDefault:
            for (;;) {
                iterationsNormal++;
                
                if(Clock.getBytecodesLeft() < stopBellowBytecodeRemaining){
                                        break mainLoop;
                }

                switch (loc.directionTo(locEnd)) {
                    case NORTH:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.NORTH))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy + 60;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 4;
                        loc = loc.add(Direction.NORTH);
                        break;
                    case NORTHEAST:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.NORTHEAST))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy + 61;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 5;
                        loc = loc.add(Direction.NORTHEAST);
                        break;
                    case EAST:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.EAST))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy + 1;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 6;
                        loc = loc.add(Direction.EAST);
                        break;
                    case SOUTHEAST:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.SOUTHEAST))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy - 59;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 7;
                        loc = loc.add(Direction.SOUTHEAST);
                        break;
                    case SOUTH:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.SOUTH))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy - 60;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 0;
                        loc = loc.add(Direction.SOUTH);
                        break;
                    case SOUTHWEST:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.SOUTHWEST))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy - 61;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 1;
                        loc = loc.add(Direction.SOUTHWEST);
                        break;
                    case WEST:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.WEST))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy - 1;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 2;
                        loc = loc.add(Direction.WEST);
                        break;
                    case NORTHWEST:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.NORTHWEST))){
                            
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                        xyTmp = xy + 59;
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                                                xy = xyTmp;
                        mapResult[xyTmp] = 3;
                        loc = loc.add(Direction.NORTHWEST);
                        break;
                    
                    case CENTER:
                        
                        break mainLoop;
                }
        
                score += mapCosts[xy];

                if(score >= MAX_SCORE){
                                        break mainLoop;
                }
            }

            /// ///////////////////// Init split mode /////////////////////
            
            xyRight = xy;
            xyLeft = xy;
            smoothLeft = 2;
            smoothRight = 2;
            locLeft = null;
            locRight= null;
            int scoreRight = 0;
            int scoreLeft = 0;
            Direction lastDirectionLeft = Direction.CENTER;
            Direction lastDirectionRight = Direction.CENTER;

            // loc.directionTo(locEnd) is an obstacle, we need to init left and right side for exploration
            switch (loc.directionTo(locEnd)) {
                case NORTH:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case NORTHEAST:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case EAST:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case SOUTHEAST:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case SOUTH:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case SOUTHWEST:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case WEST:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                case NORTHWEST:
                    // Look for the first empty cell
                    initSideLeft:{
                    if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        ctrLeft = 1;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        ctrLeft = 2;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        ctrLeft = 3;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        ctrLeft = 4;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        ctrLeft = 5;
                        break initSideLeft;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        ctrLeft = 6;
                        break initSideLeft;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                    if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        ctrRight = 1;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        ctrRight = 2;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        ctrRight = 3;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] < cost_max_per_cell) {
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        ctrRight = 4;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] < cost_max_per_cell) {
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        ctrRight = 5;
                        break initSideRight;
                    }
                    
                    if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] < cost_max_per_cell) {
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        ctrRight = 6;
                        break initSideRight;
                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                        break;
                
                default:
                    throw new java.lang.Error("ERR Pathfinding: dir is center when split init");
            }
            // TODO: Add default score for left / right depending situation
            scoreLeft = score + mapCosts[xyLeft];
            scoreRight = score + mapCosts[xyRight];

            /////////////////////////////////// Split mode ////////////////////////////////
            /// The direction we want to take is blocked, we will split bugnav to right and left
            /// We advance side with the lowest score, with score = distance for example
            /// When dir is not blocked anymore, we go back to modeDefault

            modeSplit:
            for (;;) {
                iterationsSplit++;
                if(Clock.getBytecodesLeft() < stopBellowBytecodeRemaining){
                                        break mainLoop;
                }

                if(scoreLeft < scoreRight){
                    if(scoreLeft >= MAX_SCORE){
                        
                        break mainLoop;
                    }

                                        
                    
                    modeSplitGoLeft: {
                    /// If we can move without obstacle, we are free !
                                        if(ctrLeft <= 0){                         switch (locLeft.directionTo(locEnd)){
                            case NORTH:
                                xyTmp = xyLeft + 60;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 4;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.NORTH);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHEAST:
                                xyTmp = xyLeft + 61;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 5;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.NORTHEAST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case EAST:
                                xyTmp = xyLeft + 1;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 6;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.EAST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHEAST:
                                xyTmp = xyLeft - 59;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 7;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.SOUTHEAST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTH:
                                xyTmp = xyLeft - 60;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 0;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.SOUTH);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHWEST:
                                xyTmp = xyLeft - 61;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 1;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.SOUTHWEST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case WEST:
                                xyTmp = xyLeft - 1;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 2;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.WEST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHWEST:
                                xyTmp = xyLeft + 59;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 3;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locLeft.add(Direction.NORTHWEST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            
                            case CENTER:
                                
                                break mainLoop;
                        }
                    }

                    //TODO: Ces 2 la peuvent se grouper ?
                    /// Otherwise, we check by turning progressively until we found a nice space
                    switch (lastDirectionLeft){
                        case NORTH:
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir NORTH");
                        case NORTHEAST:
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir NORTHEAST");
                        case EAST:
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir EAST");
                        case SOUTHEAST:
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir SOUTHEAST");
                        case SOUTH:
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir SOUTH");
                        case SOUTHWEST:
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir SOUTHWEST");
                        case WEST:
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir WEST");
                        case NORTHWEST:
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir NORTHWEST");
                        
                        case CENTER:
                            throw new java.lang.Error("ERR Pathfinding: previous dir is center");
                    }
                    } // End modeSplitGoLeft

                                                        }else{
                    
                    
                            

                                                            
                    
                    modeSplitGoRight: {
                    /// If we can move without obstacle, we are free !
                                        if(ctrRight <= 0){                         switch (locRight.directionTo(locEnd)){
                            case NORTH:
                                xyTmp = xyRight + 60;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 4;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.NORTH);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHEAST:
                                xyTmp = xyRight + 61;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 5;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.NORTHEAST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case EAST:
                                xyTmp = xyRight + 1;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 6;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.EAST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHEAST:
                                xyTmp = xyRight - 59;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 7;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.SOUTHEAST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTH:
                                xyTmp = xyRight - 60;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 0;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.SOUTH);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHWEST:
                                xyTmp = xyRight - 61;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 1;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.SOUTHWEST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case WEST:
                                xyTmp = xyRight - 1;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 2;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.WEST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHWEST:
                                xyTmp = xyRight + 59;
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 3;
                                    xyLastWallLeave = xyTmp;
                                    
                                    loc = locRight.add(Direction.NORTHWEST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            
                            case CENTER:
                                
                                break mainLoop;
                        }
                    }

                    //TODO: Ces 2 la peuvent se grouper ?
                    /// Otherwise, we check by turning progressively until we found a nice space
                    switch (lastDirectionRight){
                        case NORTH:
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir NORTH");
                        case NORTHEAST:
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir NORTHEAST");
                        case EAST:
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir EAST");
                        case SOUTHEAST:
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir SOUTHEAST");
                        case SOUTH:
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir SOUTH");
                        case SOUTHWEST:
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir SOUTHWEST");
                        case WEST:
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir WEST");
                        case NORTHWEST:
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                

                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir NORTHWEST");
                        
                        case CENTER:
                            throw new java.lang.Error("ERR Pathfinding: previous dir is center");
                    }
                    } // End modeSplitGoRight

                                        

                                                        }

            }// End main for loop
        } // End mainLoopLabel

        if(!withReturn){
            System.out.println("===Pathfinding report : Backtracking===");
            System.out.println("Iterations normal : " + iterationsNormal);
            System.out.println("Iterations split  : " + iterationsSplit);
            System.out.println("Bytecode used     : " + (startRemainingBytecode - Clock.getBytecodesLeft()));
            System.out.println("");

            
            BugNav.mapResult = mapResult;
            return;
        }

        
        /// Now, we want to make the path in reverse to optimize it
        // We take by priority :
        // 1) xyLastWallLeave
        // 2) Best beetween xyLeft and xyRight
        // 3) xy

        int xyReturn;
        if(xyLastWallLeave != -1){
            xyReturn = xyLastWallLeave; // 1)
            
        }else{
                        if(locLeft == null){
                                xyReturn = xyRight;

            }else{
                if(locRight == null){
                                        xyReturn = xyLeft;

                }else{
                    if(locEnd.distanceSquaredTo(locLeft) < locEnd.distanceSquaredTo(locRight)){ // 2)
                        xyReturn = xyLeft;
                        

                    }else{
                        xyReturn = xyRight;
                                            }
                }
            }

            // 3)
            if(xyReturn == -1){
                
                xyReturn = xy;
            }

        }

        if(xyReturn == -1){
            throw new java.lang.Error("ERR Pathfinding: xyReturn is -1");
        }

        loc = new MapLocation(xyReturn % 60, xyReturn / 60);
        mode = "BACK";
        int returnDirection = mapResult[xyReturn];
        int iterationsReturn = 0;
        backtrackingLoop:
        for(;;){
            iterationsReturn++;
            if(Clock.getBytecodesLeft() < stopBellowBytecodeRemaining){
                                break backtrackingLoop;
            }


            
            switch(loc.directionTo(startLoc)){
                case NORTH:
                    if(0 != returnDirection && mapCosts[xyReturn + 60] < cost_max_per_cell){
                                                loc = loc.add(Direction.NORTH);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case NORTHEAST:
                    if(1 != returnDirection && mapCosts[xyReturn + 61] < cost_max_per_cell){
                                                loc = loc.add(Direction.NORTHEAST);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case EAST:
                    if(2 != returnDirection && mapCosts[xyReturn + 1] < cost_max_per_cell){
                                                loc = loc.add(Direction.EAST);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case SOUTHEAST:
                    if(3 != returnDirection && mapCosts[xyReturn - 59] < cost_max_per_cell){
                                                loc = loc.add(Direction.SOUTHEAST);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case SOUTH:
                    if(4 != returnDirection && mapCosts[xyReturn - 60] < cost_max_per_cell){
                                                loc = loc.add(Direction.SOUTH);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case SOUTHWEST:
                    if(5 != returnDirection && mapCosts[xyReturn - 61] < cost_max_per_cell){
                                                loc = loc.add(Direction.SOUTHWEST);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case WEST:
                    if(6 != returnDirection && mapCosts[xyReturn - 1] < cost_max_per_cell){
                                                loc = loc.add(Direction.WEST);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                case NORTHWEST:
                    if(7 != returnDirection && mapCosts[xyReturn + 59] < cost_max_per_cell){
                                                loc = loc.add(Direction.NORTHWEST);     
                        break backtrackingLoop;
                    }else{
                                            }
                    break;
                
                case CENTER:
                                        BugNav.mapResult = mapResult;
                    return;
            }

            switch(returnDirection){
                case 0: // NORTH
                    
                    xyReturn += 60;
                    loc = loc.add(Direction.NORTH);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 4;
                    break;
                case 1: // NORTHEAST
                    
                    xyReturn += 61;
                    loc = loc.add(Direction.NORTHEAST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 5;
                    break;
                case 2: // EAST
                    
                    xyReturn += 1;
                    loc = loc.add(Direction.EAST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 6;
                    break;
                case 3: // SOUTHEAST
                    
                    xyReturn += -59;
                    loc = loc.add(Direction.SOUTHEAST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 7;
                    break;
                case 4: // SOUTH
                    
                    xyReturn += -60;
                    loc = loc.add(Direction.SOUTH);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 0;
                    break;
                case 5: // SOUTHWEST
                    
                    xyReturn += -61;
                    loc = loc.add(Direction.SOUTHWEST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 1;
                    break;
                case 6: // WEST
                    
                    xyReturn += -1;
                    loc = loc.add(Direction.WEST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 2;
                    break;
                case 7: // NORTHWEST
                    
                    xyReturn += 59;
                    loc = loc.add(Direction.NORTHWEST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 3;
                    break;
                            }
        }// End backtrackingLoop

        System.out.println("===Pathfinding report : Normal===");
        System.out.println("Iterations normal : " + iterationsNormal);
        System.out.println("Iterations split  : " + iterationsSplit);
        System.out.println("Iterations return : " + iterationsReturn);
        System.out.println("Bytecode used     : " + (startRemainingBytecode - Clock.getBytecodesLeft()));
        System.out.println("");

        generatePathTo(
            loc, startLoc, 
            mapCosts, mapResult, MAX_SCORE,  false, 
            cost_max_per_cell, maxBytecodeUsed
        );
    }

    public static char[] generateEmptyMapCosts(){
        return "\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00dc\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8".toCharArray();
    }

    public static char[] getMap3600(){
        return "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000".toCharArray();
    }
}