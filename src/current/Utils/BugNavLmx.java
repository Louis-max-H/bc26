// #########################################################
// !!!!!!!!!! This file is generated by jinja.py !!!!!!!!!!!
// !!!! Dont edit it manually, check in template folder !!!!
// #########################################################

//  Destination: Utils/BugNavLmx.java


 

package current.Utils;
import battlecode.common.*;
import current.Robots.Robot;

//@formatter:off





public class BugNavLmx {
    public static int width = 60;
    public static int height = 60;
    public static int SCORE_CELL_WALL = 32000; // Should not exceed 8 bits int (If added to anything else, to not overflow)
    public static int SCORE_CELL_IF_DIG = 220;
    public static int SCORE_CELL_PASSABLE = 200;

    public static void init(int width, int height){
        BugNavLmx.width = width;
        BugNavLmx.height = height;
    }

    public static boolean onTheMap(MapLocation loc){
        return loc.x >= 0 && loc.x < width && loc.y >= 0 && loc.y < height;
    }

    // Attributs for caching
    public static int timeBeforeRefresh = 0;
    public static MapLocation lastDestination;

    // Used for backtracking
    public static int resultCode = 0; // 1 : Ok, -1: Not enought bytecode
    public static String mode = "DEFAULT";
    public static int xyLastWallHit = -1;
    public static int xyLastWallLeave = -1;

    // Used for pathfinding
    public static char[] mapResult;
    public static char[] mapCosts = generateEmptyMapCosts();


    // Convert direction (char value) at index startXY to Direction enum
    public static Direction getResult(int startXY){
        return switch(mapResult[startXY]){
                        case 0 -> Direction.NORTH;
                        case 1 -> Direction.NORTHEAST;
                        case 2 -> Direction.EAST;
                        case 3 -> Direction.SOUTHEAST;
                        case 4 -> Direction.SOUTH;
                        case 5 -> Direction.SOUTHWEST;
                        case 6 -> Direction.WEST;
                        case 7 -> Direction.NORTHWEST;
            
            default -> {
               RobotController rc = Robot.rc;if( rc.getRoundNum() < 150){
                    System.out.println("Unknow direction return from Pathfinding : " + (int)mapResult[startXY]);
                }
                yield Direction.CENTER;
            }
        };
    }


    // Wrapper for pathfinding with less parameters
    public static Direction pathTo(
        MapLocation startLoc, MapLocation endLoc,
        char[] mapCosts, int MAX_SCORE, int cost_max_per_cell, int maxBytecodeUsed
    ) throws GameActionException {
        

        // Check if cost_max_per_cell is greater than SCORE_CELL_WALL
        if(cost_max_per_cell > 32000){
            throw new java.lang.Error("ERR Pathfinding: cost_max_per_cell is greater than SCORE_CELL_WALL {{SCORE_CELL_WALL}}");
        }

        int startXY = startLoc.x + 60*startLoc.y;

        RobotController rc = Robot.rc;if( rc.getRoundNum() < 150){
            System.out.println("Start Pathfinding from " + startLoc + " to " + endLoc);
        }
        
        // Check if we can reuse previous path
        Direction dir;
        if(mapCosts == null){mapCosts = BugNavLmx.mapCosts;}
        if(timeBeforeRefresh > 0 && lastDestination.equals(endLoc)){
            dir = getResult(startXY);
            if(dir != Direction.CENTER){
                System.out.println("Pathfinding: Reuse previous path -> " + dir);
                timeBeforeRefresh -= 3;
                return dir;
            }
        }

        // Generate path
        mode = "DEFAULT";
        resultCode = generatePathTo(startLoc, endLoc, mapCosts, getMap3600(), MAX_SCORE, true, cost_max_per_cell, maxBytecodeUsed);
        
        // Check result validity
        dir = getResult(startXY);
        if(resultCode < 0){
            if(rc.getRoundNum() < 150){
                System.out.println("Pathfinding: Warning return code : " + resultCode + " : " + dir);
            }    
            timeBeforeRefresh = 0; // Don't save query result
            
        }else{
            if(rc.getRoundNum() < 150){
                System.out.println("Pathfinding: SUCCESS -> " + dir);
            }
            timeBeforeRefresh = 3; // Save query result for 3 rounds
            lastDestination = endLoc;
        }
        return dir;
    }


    private static int generatePathTo(
        MapLocation startLoc, MapLocation endLoc, 
        char[] mapCosts, char[] mapResult,
        int MAX_SCORE, boolean withReturn, 
        int cost_max_per_cell, int maxBytecodeUsed) throws GameActionException {

        RobotController rc = Robot.rc;// Initialize variables
        int xy = startLoc.x + 60*startLoc.y;
        int xyEnd = endLoc.x + 60*endLoc.y;
        int xyTmp;
        int xyLeft = -1;
        int xyRight = -1;
        int ctrRight = 0;
        int ctrLeft = 0;
        int smoothLeft;
        int smoothRight;
        mapResult[xy] = 8;
        MapLocation loc = new MapLocation(startLoc.x, startLoc.y);
        MapLocation locEnd = new MapLocation(endLoc.x, endLoc.y);


        // Initialize result variables
        int score = 0;
        xyLastWallHit = -1;
        xyLastWallLeave = -1;
        MapLocation locLeft = null;
        MapLocation locRight = null;


        // Bytecode and benchmark variables
        int iterationsSplit = 0;
        int iterationsNormal = 0;
        int startRemainingBytecode =  Clock.getBytecodesLeft() ;
        int stopBellowBytecodeRemaining;
        if(withReturn){
            stopBellowBytecodeRemaining =  Clock.getBytecodesLeft() - maxBytecodeUsed / 3 ;
        }else{
            stopBellowBytecodeRemaining =  Clock.getBytecodesLeft() - maxBytecodeUsed ;
        }
        


        mainLoop: // We exit the loop when direction to target is Direction.CENTER
        for(;;) {

            /////////////////////////////////// Default mode ////////////////////////////////
            /// we just go to the direction. If wall, we check if better left or right and enter left or right mode then
            modeDefault:
            for (;;) {
                iterationsNormal++;

                                                if(Clock.getBytecodesLeft() < stopBellowBytecodeRemaining){
                    break mainLoop;
                }

                                switch (loc.directionTo(locEnd)) {
                    case NORTH:

                                                if(!onTheMap(loc.add(Direction.NORTH))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy + 60;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.NORTH);
                        mapResult[xyTmp] = 4;
                        break;
                    case NORTHEAST:

                                                if(!onTheMap(loc.add(Direction.NORTHEAST))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy + 61;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.NORTHEAST);
                        mapResult[xyTmp] = 5;
                        break;
                    case EAST:

                                                if(!onTheMap(loc.add(Direction.EAST))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy + 1;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.EAST);
                        mapResult[xyTmp] = 6;
                        break;
                    case SOUTHEAST:

                                                if(!onTheMap(loc.add(Direction.SOUTHEAST))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy - 59;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.SOUTHEAST);
                        mapResult[xyTmp] = 7;
                        break;
                    case SOUTH:

                                                if(!onTheMap(loc.add(Direction.SOUTH))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy - 60;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.SOUTH);
                        mapResult[xyTmp] = 0;
                        break;
                    case SOUTHWEST:

                                                if(!onTheMap(loc.add(Direction.SOUTHWEST))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy - 61;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.SOUTHWEST);
                        mapResult[xyTmp] = 1;
                        break;
                    case WEST:

                                                if(!onTheMap(loc.add(Direction.WEST))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy - 1;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.WEST);
                        mapResult[xyTmp] = 2;
                        break;
                    case NORTHWEST:

                                                if(!onTheMap(loc.add(Direction.NORTHWEST))){
                            throw new java.lang.Error("ERR Pathfinding: Reach a border when direction to cell on map");
                        }

                                                xyTmp = xy + 59;
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                                                xy = xyTmp;
                        loc = loc.add(Direction.NORTHWEST);
                        mapResult[xyTmp] = 3;
                        break;
                    
                                        case CENTER:
                        break mainLoop;
                }
        
                                score += mapCosts[xy];
                if(score >= MAX_SCORE){ // We haven't enough score to reach our destination
                    break mainLoop;
                }
            }


            /// ///////////////////// Init split mode /////////////////////
                        xyLeft = xy;
            xyRight = xy;
            locLeft = null;
            locRight= null;
            smoothLeft = 2;
            smoothRight = 2;
            int scoreLeft = 0;
            int scoreRight = 0;
            Direction lastDirectionLeft = Direction.CENTER;
            Direction lastDirectionRight = Direction.CENTER;

            // loc.directionTo(locEnd) is an obstacle, we need to init left and right side for exploration
            switch (loc.directionTo(locEnd)) {

                case NORTH:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        mapResult[xyLeft] = 5;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        mapResult[xyLeft] = 6;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        mapResult[xyLeft] = 7;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        mapResult[xyLeft] = 0;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        mapResult[xyLeft] = 1;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        mapResult[xyLeft] = 2;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        mapResult[xyRight] = 3;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        mapResult[xyRight] = 2;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        mapResult[xyRight] = 1;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        mapResult[xyRight] = 0;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        mapResult[xyRight] = 7;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        mapResult[xyRight] = 6;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case NORTHEAST:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        mapResult[xyLeft] = 6;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        mapResult[xyLeft] = 7;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        mapResult[xyLeft] = 0;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        mapResult[xyLeft] = 1;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        mapResult[xyLeft] = 2;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        mapResult[xyLeft] = 3;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        mapResult[xyRight] = 4;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        mapResult[xyRight] = 3;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        mapResult[xyRight] = 2;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        mapResult[xyRight] = 1;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        mapResult[xyRight] = 0;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        mapResult[xyRight] = 7;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case EAST:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        mapResult[xyLeft] = 7;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        mapResult[xyLeft] = 0;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        mapResult[xyLeft] = 1;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        mapResult[xyLeft] = 2;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        mapResult[xyLeft] = 3;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        mapResult[xyLeft] = 4;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        mapResult[xyRight] = 5;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        mapResult[xyRight] = 4;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        mapResult[xyRight] = 3;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        mapResult[xyRight] = 2;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        mapResult[xyRight] = 1;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        mapResult[xyRight] = 0;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case SOUTHEAST:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        mapResult[xyLeft] = 0;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        mapResult[xyLeft] = 1;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        mapResult[xyLeft] = 2;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        mapResult[xyLeft] = 3;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        mapResult[xyLeft] = 4;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        mapResult[xyLeft] = 5;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        mapResult[xyRight] = 6;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        mapResult[xyRight] = 5;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        mapResult[xyRight] = 4;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        mapResult[xyRight] = 3;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        mapResult[xyRight] = 2;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        mapResult[xyRight] = 1;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case SOUTH:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        mapResult[xyLeft] = 1;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        mapResult[xyLeft] = 2;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        mapResult[xyLeft] = 3;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        mapResult[xyLeft] = 4;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        mapResult[xyLeft] = 5;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        mapResult[xyLeft] = 6;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        mapResult[xyRight] = 7;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        mapResult[xyRight] = 6;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        mapResult[xyRight] = 5;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        mapResult[xyRight] = 4;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        mapResult[xyRight] = 3;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        mapResult[xyRight] = 2;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case SOUTHWEST:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.WEST);
                        xyLeft = xy - 1;
                        lastDirectionLeft = Direction.WEST;
                        mapResult[xyLeft] = 2;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        mapResult[xyLeft] = 3;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        mapResult[xyLeft] = 4;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        mapResult[xyLeft] = 5;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        mapResult[xyLeft] = 6;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        mapResult[xyLeft] = 7;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        mapResult[xyRight] = 0;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        mapResult[xyRight] = 7;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        mapResult[xyRight] = 6;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        mapResult[xyRight] = 5;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        mapResult[xyRight] = 4;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.NORTHWEST);
                        xyRight = xy + 59;
                        lastDirectionRight = Direction.NORTHWEST;
                        mapResult[xyRight] = 3;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case WEST:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.NORTHWEST)) && mapCosts[xy + 59] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.NORTHWEST);
                        xyLeft = xy + 59;
                        lastDirectionLeft = Direction.NORTHWEST;
                        mapResult[xyLeft] = 3;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        mapResult[xyLeft] = 4;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        mapResult[xyLeft] = 5;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        mapResult[xyLeft] = 6;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        mapResult[xyLeft] = 7;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        mapResult[xyLeft] = 0;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        mapResult[xyRight] = 1;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        mapResult[xyRight] = 0;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        mapResult[xyRight] = 7;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        mapResult[xyRight] = 6;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        mapResult[xyRight] = 5;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.NORTH);
                        xyRight = xy + 60;
                        lastDirectionRight = Direction.NORTH;
                        mapResult[xyRight] = 4;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                case NORTHWEST:
                
                    initSideLeft:{
                                        if(onTheMap(loc.add(Direction.NORTH)) && mapCosts[xy + 60] <= cost_max_per_cell) {
                                                ctrLeft = 1;
                        locLeft = loc.add(Direction.NORTH);
                        xyLeft = xy + 60;
                        lastDirectionLeft = Direction.NORTH;
                        mapResult[xyLeft] = 4;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrLeft = 2;
                        locLeft = loc.add(Direction.NORTHEAST);
                        xyLeft = xy + 61;
                        lastDirectionLeft = Direction.NORTHEAST;
                        mapResult[xyLeft] = 5;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrLeft = 3;
                        locLeft = loc.add(Direction.EAST);
                        xyLeft = xy + 1;
                        lastDirectionLeft = Direction.EAST;
                        mapResult[xyLeft] = 6;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrLeft = 4;
                        locLeft = loc.add(Direction.SOUTHEAST);
                        xyLeft = xy - 59;
                        lastDirectionLeft = Direction.SOUTHEAST;
                        mapResult[xyLeft] = 7;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrLeft = 5;
                        locLeft = loc.add(Direction.SOUTH);
                        xyLeft = xy - 60;
                        lastDirectionLeft = Direction.SOUTH;
                        mapResult[xyLeft] = 0;

                                                break initSideLeft;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrLeft = 6;
                        locLeft = loc.add(Direction.SOUTHWEST);
                        xyLeft = xy - 61;
                        lastDirectionLeft = Direction.SOUTHWEST;
                        mapResult[xyLeft] = 1;

                                                break initSideLeft;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideLeft
                    initSideRight:{
                                        if(onTheMap(loc.add(Direction.WEST)) && mapCosts[xy - 1] <= cost_max_per_cell) {
                                                ctrRight = 1;
                        locRight = loc.add(Direction.WEST);
                        xyRight = xy - 1;
                        lastDirectionRight = Direction.WEST;
                        mapResult[xyRight] = 2;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHWEST)) && mapCosts[xy - 61] <= cost_max_per_cell) {
                                                ctrRight = 2;
                        locRight = loc.add(Direction.SOUTHWEST);
                        xyRight = xy - 61;
                        lastDirectionRight = Direction.SOUTHWEST;
                        mapResult[xyRight] = 1;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTH)) && mapCosts[xy - 60] <= cost_max_per_cell) {
                                                ctrRight = 3;
                        locRight = loc.add(Direction.SOUTH);
                        xyRight = xy - 60;
                        lastDirectionRight = Direction.SOUTH;
                        mapResult[xyRight] = 0;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.SOUTHEAST)) && mapCosts[xy - 59] <= cost_max_per_cell) {
                                                ctrRight = 4;
                        locRight = loc.add(Direction.SOUTHEAST);
                        xyRight = xy - 59;
                        lastDirectionRight = Direction.SOUTHEAST;
                        mapResult[xyRight] = 7;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.EAST)) && mapCosts[xy + 1] <= cost_max_per_cell) {
                                                ctrRight = 5;
                        locRight = loc.add(Direction.EAST);
                        xyRight = xy + 1;
                        lastDirectionRight = Direction.EAST;
                        mapResult[xyRight] = 6;

                                                break initSideRight;

                    }
                                        if(onTheMap(loc.add(Direction.NORTHEAST)) && mapCosts[xy + 61] <= cost_max_per_cell) {
                                                ctrRight = 6;
                        locRight = loc.add(Direction.NORTHEAST);
                        xyRight = xy + 61;
                        lastDirectionRight = Direction.NORTHEAST;
                        mapResult[xyRight] = 5;

                                                break initSideRight;

                    }
                    
                    throw new java.lang.Error("ERR Pathfinding: impossible to init split mode (All directions are blocked)");
                    } // End initSideRight
                                         break;

                     
                default:
                    throw new java.lang.Error("ERR Pathfinding: dir is center when split init");
            }

            
            // TODO: Add default score for left / right depending situation
            scoreLeft = score + mapCosts[xyLeft];
            scoreRight = score + mapCosts[xyRight];

            /////////////////////////////////// Split mode ////////////////////////////////
            /// The direction we want to take is blocked, we will split bugnav to right and left
            /// We advance side with the lowest score, with score = distance for example
            /// When dir is not blocked anymore, we go back to modeDefault

            modeSplit:
            for (;;) {
                iterationsSplit++;
                if(Clock.getBytecodesLeft() < stopBellowBytecodeRemaining){
                    break mainLoop;
                }

                if(scoreLeft < scoreRight + SCORE_CELL_PASSABLE * 4){ // Little advantage on right
                    if(scoreLeft >= MAX_SCORE){
                        break mainLoop;
                    }

                                        modeSplitGoLeft: {
                    /// If we can move without obstacle, we are free !
                                        if(ctrLeft <= 0){                         switch (locLeft.directionTo(locEnd)){
                            case NORTH:
                                xyTmp = xyLeft + 60;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 4;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.NORTH);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHEAST:
                                xyTmp = xyLeft + 61;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 5;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.NORTHEAST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case EAST:
                                xyTmp = xyLeft + 1;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 6;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.EAST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHEAST:
                                xyTmp = xyLeft - 59;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 7;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.SOUTHEAST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTH:
                                xyTmp = xyLeft - 60;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 0;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.SOUTH);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHWEST:
                                xyTmp = xyLeft - 61;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 1;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.SOUTHWEST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case WEST:
                                xyTmp = xyLeft - 1;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 2;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.WEST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHWEST:
                                xyTmp = xyLeft + 59;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothLeft <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 3;
                                    xyLastWallLeave = xyTmp;
                                    loc = locLeft.add(Direction.NORTHWEST);
                                    score = scoreLeft + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            
                            case CENTER:
                                break mainLoop;
                        }
                    }

                    //TODO: Ces 2 la peuvent se grouper ?
                    /// Otherwise, we check by turning progressively until we found a nice space
                    switch (lastDirectionLeft){
                        case NORTH:
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir NORTH");
                        case NORTHEAST:
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir NORTHEAST");
                        case EAST:
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir EAST");
                        case SOUTHEAST:
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir SOUTHEAST");
                        case SOUTH:
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir SOUTH");
                        case SOUTHWEST:
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir SOUTHWEST");
                        case WEST:
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir WEST");
                        case NORTHWEST:
                            if(!onTheMap(locLeft.add(Direction.SOUTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -2;
                                mapResult[xyTmp] = 1;

                                locLeft = locLeft.add(Direction.SOUTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.WEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += -1;
                                mapResult[xyTmp] = 2;

                                locLeft = locLeft.add(Direction.WEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.WEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHWEST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 0;
                                mapResult[xyTmp] = 3;

                                locLeft = locLeft.add(Direction.NORTHWEST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHWEST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 1;
                                mapResult[xyTmp] = 4;

                                locLeft = locLeft.add(Direction.NORTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTH;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.NORTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 2;
                                mapResult[xyTmp] = 5;

                                locLeft = locLeft.add(Direction.NORTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.NORTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.EAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 3;
                                mapResult[xyTmp] = 6;

                                locLeft = locLeft.add(Direction.EAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.EAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTHEAST))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 4;
                                mapResult[xyTmp] = 7;

                                locLeft = locLeft.add(Direction.SOUTHEAST);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTHEAST;
                                break modeSplitGoLeft;
                            }
                            if(!onTheMap(locLeft.add(Direction.SOUTH))) {
                                scoreLeft = MAX_SCORE;
                                break modeSplitGoLeft;
                            }

                            xyTmp = xyLeft - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyLeft = xyTmp;
                                ctrLeft += 5;
                                mapResult[xyTmp] = 0;

                                locLeft = locLeft.add(Direction.SOUTH);
                                scoreLeft += mapCosts[xyTmp];
                                lastDirectionLeft = Direction.SOUTH;
                                break modeSplitGoLeft;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Left and previous dir NORTHWEST");
                        
                        case CENTER:
                            throw new java.lang.Error("ERR Pathfinding: previous dir is center");
                    }
                    } // End modeSplitGoLeft

                                                        }else{
                                                            modeSplitGoRight: {
                    /// If we can move without obstacle, we are free !
                                        if(ctrRight <= 0){                         switch (locRight.directionTo(locEnd)){
                            case NORTH:
                                xyTmp = xyRight + 60;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 4;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.NORTH);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHEAST:
                                xyTmp = xyRight + 61;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 5;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.NORTHEAST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case EAST:
                                xyTmp = xyRight + 1;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 6;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.EAST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHEAST:
                                xyTmp = xyRight - 59;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 7;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.SOUTHEAST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTH:
                                xyTmp = xyRight - 60;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 0;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.SOUTH);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case SOUTHWEST:
                                xyTmp = xyRight - 61;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 1;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.SOUTHWEST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case WEST:
                                xyTmp = xyRight - 1;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 2;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.WEST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            case NORTHWEST:
                                xyTmp = xyRight + 59;
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smoothRight <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = 3;
                                    xyLastWallLeave = xyTmp;
                                    loc = locRight.add(Direction.NORTHWEST);
                                    score = scoreRight + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            
                            case CENTER:
                                break mainLoop;
                        }
                    }

                    //TODO: Ces 2 la peuvent se grouper ?
                    /// Otherwise, we check by turning progressively until we found a nice space
                    switch (lastDirectionRight){
                        case NORTH:
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir NORTH");
                        case NORTHEAST:
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir NORTHEAST");
                        case EAST:
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir EAST");
                        case SOUTHEAST:
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir SOUTHEAST");
                        case SOUTH:
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir SOUTH");
                        case SOUTHWEST:
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir SOUTHWEST");
                        case WEST:
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir WEST");
                        case NORTHWEST:
                            if(!onTheMap(locRight.add(Direction.NORTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -2;
                                mapResult[xyTmp] = 5;

                                locRight = locRight.add(Direction.NORTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += -1;
                                mapResult[xyTmp] = 4;

                                locRight = locRight.add(Direction.NORTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.NORTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 0;
                                mapResult[xyTmp] = 3;

                                locRight = locRight.add(Direction.NORTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.NORTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.WEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 1;
                                mapResult[xyTmp] = 2;

                                locRight = locRight.add(Direction.WEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.WEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHWEST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 61;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 2;
                                mapResult[xyTmp] = 1;

                                locRight = locRight.add(Direction.SOUTHWEST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHWEST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTH))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 60;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 3;
                                mapResult[xyTmp] = 0;

                                locRight = locRight.add(Direction.SOUTH);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTH;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.SOUTHEAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight - 59;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 4;
                                mapResult[xyTmp] = 7;

                                locRight = locRight.add(Direction.SOUTHEAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.SOUTHEAST;
                                break modeSplitGoRight;
                            }
                            if(!onTheMap(locRight.add(Direction.EAST))) {
                                scoreRight = MAX_SCORE;
                                break modeSplitGoRight;
                            }

                            xyTmp = xyRight + 1;
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                xyRight = xyTmp;
                                ctrRight += 5;
                                mapResult[xyTmp] = 6;

                                locRight = locRight.add(Direction.EAST);
                                scoreRight += mapCosts[xyTmp];
                                lastDirectionRight = Direction.EAST;
                                break modeSplitGoRight;
                            }
                            throw new java.lang.Error("ERR Pathfinding: Can't find solution for side Right and previous dir NORTHWEST");
                        
                        case CENTER:
                            throw new java.lang.Error("ERR Pathfinding: previous dir is center");
                    }
                    } // End modeSplitGoRight

                                                                            }

            }// End main for loop
        } // End mainLoopLabel

        if(!withReturn){
            if( rc.getRoundNum() < 150){
                System.out.println("===Pathfinding report : Backtracking===");
                System.out.println("Iterations normal : " + iterationsNormal);
                System.out.println("Iterations split  : " + iterationsSplit);
                System.out.println("Bytecode used     : " + (startRemainingBytecode - Clock.getBytecodesLeft()));
            }

            BugNavLmx.mapResult = mapResult;
            if(xy != xyEnd){
                return -1;
            }
            return 1;
        }

        /// Now, we want to make the path in reverse to optimize it
        // We take by priority :
        // 1) xyLastWallLeave
        // 2) Best beetween xyLeft and xyRight
        // 3) xy

        int xyReturn;
        if(xyLastWallLeave != -1){
            xyReturn = xyLastWallLeave; // 1)
            }else{
            if(locLeft == null){
                xyReturn = xyRight;

            }else{
                if(locRight == null){
                    xyReturn = xyLeft;

                }else{
                    if(locEnd.distanceSquaredTo(locLeft) < locEnd.distanceSquaredTo(locRight)){ // 2)
                        xyReturn = xyLeft;
                        }else{
                        xyReturn = xyRight;
                        }
                }
            }

            // 3)
            if(xyReturn == -1){
                xyReturn = xy;
            }

        }

        if(xyReturn == -1){
            throw new java.lang.Error("ERR Pathfinding: xyReturn is -1");
        }

        loc = new MapLocation(xyReturn % 60, xyReturn / 60);
        mode = "BACK";
        int returnDirection = mapResult[xyReturn];
        int iterationsReturn = 0;
        backtrackingLoop:
        for(;;){
            iterationsReturn++;
            if(Clock.getBytecodesLeft() < stopBellowBytecodeRemaining){
                break backtrackingLoop;
            }

            switch(loc.directionTo(startLoc)){
                case NORTH:
                    if(0 != returnDirection && mapCosts[xyReturn + 60] <= cost_max_per_cell){
                        loc = loc.add(Direction.NORTH);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case NORTHEAST:
                    if(1 != returnDirection && mapCosts[xyReturn + 61] <= cost_max_per_cell){
                        loc = loc.add(Direction.NORTHEAST);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case EAST:
                    if(2 != returnDirection && mapCosts[xyReturn + 1] <= cost_max_per_cell){
                        loc = loc.add(Direction.EAST);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case SOUTHEAST:
                    if(3 != returnDirection && mapCosts[xyReturn - 59] <= cost_max_per_cell){
                        loc = loc.add(Direction.SOUTHEAST);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case SOUTH:
                    if(4 != returnDirection && mapCosts[xyReturn - 60] <= cost_max_per_cell){
                        loc = loc.add(Direction.SOUTH);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case SOUTHWEST:
                    if(5 != returnDirection && mapCosts[xyReturn - 61] <= cost_max_per_cell){
                        loc = loc.add(Direction.SOUTHWEST);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case WEST:
                    if(6 != returnDirection && mapCosts[xyReturn - 1] <= cost_max_per_cell){
                        loc = loc.add(Direction.WEST);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                case NORTHWEST:
                    if(7 != returnDirection && mapCosts[xyReturn + 59] <= cost_max_per_cell){
                        loc = loc.add(Direction.NORTHWEST);     
                        break backtrackingLoop;
                    }else{
                        }
                    break;
                
                case CENTER:
                    BugNavLmx.mapResult = mapResult;
                    return 1;
            }

            switch(returnDirection){
                case 0: // NORTH
                    xyReturn += 60;
                    loc = loc.add(Direction.NORTH);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 4;
                    break;
                case 1: // NORTHEAST
                    xyReturn += 61;
                    loc = loc.add(Direction.NORTHEAST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 5;
                    break;
                case 2: // EAST
                    xyReturn += 1;
                    loc = loc.add(Direction.EAST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 6;
                    break;
                case 3: // SOUTHEAST
                    xyReturn += -59;
                    loc = loc.add(Direction.SOUTHEAST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 7;
                    break;
                case 4: // SOUTH
                    xyReturn += -60;
                    loc = loc.add(Direction.SOUTH);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 0;
                    break;
                case 5: // SOUTHWEST
                    xyReturn += -61;
                    loc = loc.add(Direction.SOUTHWEST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 1;
                    break;
                case 6: // WEST
                    xyReturn += -1;
                    loc = loc.add(Direction.WEST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 2;
                    break;
                case 7: // NORTHWEST
                    xyReturn += 59;
                    loc = loc.add(Direction.NORTHWEST);
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = 3;
                    break;
                            }
        }// End backtrackingLoop

        if( rc.getRoundNum() < 150){
            System.out.println("===Pathfinding report : Normal===");
            System.out.println("Iterations normal : " + iterationsNormal);
            System.out.println("Iterations split  : " + iterationsSplit);
            System.out.println("Iterations return : " + iterationsReturn);
            System.out.println("Bytecode used     : " + (startRemainingBytecode - Clock.getBytecodesLeft()));
            System.out.println("");
        }

        return generatePathTo(
            loc, startLoc, 
            mapCosts, mapResult, MAX_SCORE,  false, 
            cost_max_per_cell, maxBytecodeUsed
        );
    }

    public static char[] generateEmptyMapCosts(){
        return "\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8\u00c8".toCharArray();
    }

    public static char[] getMap3600(){
        return "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000".toCharArray();
    }
}