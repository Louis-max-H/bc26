//  Destination: Utils/BugNav.java

{% set SCORE_CELL_PASSABLE  =    200 %}
{% set SCORE_CELL_IF_DIG    =    220 %}
{% set SCORE_CELL_WALL      =  32000 %}
{% set DEBUG = false %}
{% set BATTLECODE = true %}

{% if BATTLECODE %}
package current.Utils;
import battlecode.common.*;
import current.Robots.Robot;

{% else -%}
package Bugnav;
import Bugnav.MapLocation;
import Bugnav.Direction;
{% endif %}
//@formatter:off

{% set dirs = ["NORTH","NORTHEAST","EAST","SOUTHEAST","SOUTH","SOUTHWEST","WEST","NORTHWEST"] %}
{% set dirsPriority = {
        'NORTH': ['NORTH', 'NORTHEAST', 'NORTHWEST', 'EAST', 'WEST', 'SOUTH', 'SOUTHEAST', 'SOUTHWEST'],
        'NORTHEAST': ['NORTHEAST', 'EAST', 'NORTH', 'NORTHWEST', 'SOUTHEAST', 'SOUTH', 'WEST', 'SOUTHWEST'],
        'EAST': ['EAST', 'NORTHEAST', 'SOUTHEAST', 'NORTH', 'SOUTH', 'WEST', 'NORTHWEST', 'SOUTHWEST'],
        'SOUTHEAST': ['SOUTHEAST', 'EAST', 'SOUTH', 'NORTHEAST', 'SOUTHWEST', 'NORTH', 'WEST', 'NORTHWEST'],
        'SOUTH': ['SOUTH', 'SOUTHEAST', 'SOUTHWEST', 'EAST', 'WEST', 'NORTH', 'NORTHEAST', 'NORTHWEST'],
        'SOUTHWEST': ['SOUTHWEST', 'SOUTH', 'WEST', 'NORTHWEST', 'SOUTHEAST', 'EAST', 'NORTH', 'NORTHEAST'],
        'WEST': ['WEST', 'WEST', 'NORTHWEST', 'SOUTHWEST', 'NORTH', 'SOUTH', 'EAST', 'NORTHEAST', 'SOUTHEAST'],
        'NORTHWEST': ['NORTHWEST', 'NORTH', 'WEST', 'NORTHEAST', 'SOUTHWEST', 'EAST', 'SOUTH', 'SOUTHEAST']
    }
%}


{% macro impossible(MSG) -%}throw new java.lang.Error("ERR Pathfinding: {{MSG}}");{%- endmacro %}


// encode(x, y) = (x+1) + (y + 1)(1 + 60 + 1) = x + 60*y
public class BugNav {
    public static int width = 60;
    public static int height = 60;

    public static int SCORE_CELL_PASSABLE = {{ SCORE_CELL_PASSABLE }};
    public static int SCORE_CELL_IF_DIG = {{ SCORE_CELL_IF_DIG }};
    public static int SCORE_CELL_WALL = {{ SCORE_CELL_WALL }}; // Should not exceed 8 bits int (If added to anything else, to not overflow)

    public static void init(int width, int height){
        BugNav.width = width;
        BugNav.height = height;
    }

    public static boolean onTheMap(MapLocation loc){
        return loc.x >= 0 && loc.x < width && loc.y >= 0 && loc.y < height;
    }

    public static int xyLastWallHit = -1;
    public static int xyLastWallLeave = -1;
    public static char[] mapResult;
    public static String mode = "DEFAULT";
    public static char[] mapCosts = generateEmptyMapCosts();

    public static void pathTo(
        MapLocation startLoc, MapLocation endLoc,
        char[] mapCosts, int MAX_SCORE, int cost_max_per_cell, int maxBytecodeUsed
    ){
        if(cost_max_per_cell > {{SCORE_CELL_WALL}}){
            {{ impossible(MSG="cost_max_per_cell is greater than SCORE_CELL_WALL {{SCORE_CELL_WALL}}") }}
        }
        mode = "DEFAULT";
        generatePathTo(startLoc, endLoc, mapCosts, getMap3600(), MAX_SCORE, true, cost_max_per_cell, maxBytecodeUsed);
    }

    public static void generatePathTo(
        MapLocation startLoc, MapLocation endLoc, 
        char[] mapCosts, char[] mapResult,
        int MAX_SCORE, boolean withReturn, 
        int cost_max_per_cell, int maxBytecodeUsed){

        {% if BATTLECODE -%}
        RobotController rc = Robot.rc;
        {% endif %}

        if(mapCosts == null){
            mapCosts = BugNav.mapCosts;
        }
        int xy = startLoc.x + 60*startLoc.y;
        int xyTmp;
        int xyLeft = -1;
        int xyRight = -1;
        int ctrRight = 0;
        int ctrLeft = 0;
        int smoothLeft;
        int smoothRight;


        int score = 0;
        xyLastWallHit = -1;
        xyLastWallLeave = -1;
        MapLocation locLeft = null;
        MapLocation locRight = null;

        // Bytecode and stats
        int iterationsSplit = 0;
        int iterationsNormal = 0;
        int startRemainingBytecode = {% if BATTLECODE %} Clock.getBytecodesLeft() {% else %} 0 {% endif %};
        int stopBellowBytecodeRemaining;
        if(withReturn){
            stopBellowBytecodeRemaining = {% if BATTLECODE %} Clock.getBytecodesLeft() - maxBytecodeUsed / 2 {% else %} 0 {% endif %};
        }else{
            stopBellowBytecodeRemaining = {% if BATTLECODE %} Clock.getBytecodesLeft() - maxBytecodeUsed {% else %} 0 {% endif %};
        }
        {% set getBytecodeRemaining = "Clock.getBytecodesLeft()" if BATTLECODE else "1" %}

        MapLocation loc = new MapLocation(startLoc.x, startLoc.y);
        MapLocation locEnd = new MapLocation(endLoc.x, endLoc.y);
        {% if DEBUG -%}System.out.println("MSG=start at " + xy);
        {% endif %}
        mapResult[xy] = {{dirsOrdsOpposite["CENTER"]}};


        mainLoop: // We exit the loop when direction to target is Direction.CENTER
        for(;;) {

            /////////////////////////////////// Default mode ////////////////////////////////
            /// we just go to the direction. If wall, we check if better left or right and enter left or right mode then
            modeDefault:
            for (;;) {
                iterationsNormal++;
                {% if DEBUG -%}
                System.out.println("MODE=" + mode + ", resume at POS=" + xy + " " + loc + " want to go to " + locEnd + " -> " + loc.directionTo(locEnd));
                if(withReturn){System.out.println("SCORE=" + score);}
                {% endif %}

                if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                    {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                    {% endif %}
                    break mainLoop;
                }

                switch (loc.directionTo(locEnd)) {
                    {% for dir in dirs -%}
                    case {{dir}}:
                        // Todos: Update mapCosts with sensing
                        if(!onTheMap(loc.add(Direction.{{dir}}))){
                            {% if DEBUG -%}System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=IMPOSSIBLE");
                            {% endif %}

                            {{ impossible(MSG="Reach a border when direction to cell on map") }}
                        }

                        xyTmp = xy + {{dirsShift60xy[dir]}};
                        if(mapCosts[xyTmp] >= cost_max_per_cell){
                            {% if DEBUG -%}System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=WALL");
                            {% endif %}

                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }


                        {% if DEBUG -%}System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=OK");
                        {% endif %}
                        xy = xyTmp;
                        mapResult[xyTmp] = {{dirsOrdsOpposite[dir]}};
                        loc = loc.add(Direction.{{dir}});
                        break;
                    {%endfor %}

                    case CENTER:
                        {% if DEBUG -%}System.out.println("MSG=CENTER");
                        {% endif %}

                        break mainLoop;
                }
        
                score += mapCosts[xy];

                if(score >= MAX_SCORE){
                    {% if DEBUG -%}System.out.println("MSG=MAX_SCORE " + score + " >= " + MAX_SCORE);
                    {% endif %}
                    break mainLoop;
                }
            }

            /// ///////////////////// Init split mode /////////////////////
            {% if DEBUG -%}System.out.println("MSG=init split mode");
            {% endif %}

            xyRight = xy;
            xyLeft = xy;
            smoothLeft = 2;
            smoothRight = 2;
            locLeft = null;
            locRight= null;
            int scoreRight = 0;
            int scoreLeft = 0;
            Direction lastDirectionLeft = Direction.CENTER;
            Direction lastDirectionRight = Direction.CENTER;

            // loc.directionTo(locEnd) is an obstacle, we need to init left and right side for exploration
            switch (loc.directionTo(locEnd)) {
                {% for dir in dirs -%}
                case {{dir}}:
                    // Look for the first empty cell
                    {% for side in ["Left", "Right"] -%}
                    initSide{{side}}:{
                    {% for i in range(1, 7) -%}
                    {% set dirTest = rotate(dir, side, i) -%}
                    if(onTheMap(loc.add(Direction.{{dirTest}})) && mapCosts[xy + {{dirsShift60xy[dirTest]}}] < cost_max_per_cell) {
                        loc{{side}} = loc.add(Direction.{{dirTest}});
                        xy{{side}} = xy + {{dirsShift60xy[dirTest]}};
                        lastDirection{{side}} = Direction.{{dirTest}};
                        {% if DEBUG -%}
                            System.out.println("POS=" + xy + ", DIR={{dirTest}}, RESULT=OK");
                            System.out.println("MSG={{side}} init to " + xy{{side}});
                        {% endif -%}
                        ctr{{side}} = {{i}};
                        break initSide{{side}};
                    }
                    {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy + ", DIR={{dirTest}}, RESULT=WALL");
                    {% endif %}

                    {% endfor -%}

                    {{ impossible(MSG="impossible to init split mode (All directions are blocked)") }}
                    } // End initSide{{side}}
                    {% endfor %}
                    break;
                {% endfor %}

                default:
                    {{ impossible(MSG="dir is center when split init") }}
            }
            // TODO: Add default score for left / right depending situation
            scoreLeft = score + mapCosts[xyLeft];
            scoreRight = score + mapCosts[xyRight];

            /////////////////////////////////// Split mode ////////////////////////////////
            /// The direction we want to take is blocked, we will split bugnav to right and left
            /// We advance side with the lowest score, with score = distance for example
            /// When dir is not blocked anymore, we go back to modeDefault

            modeSplit:
            for (;;) {
                iterationsSplit++;
                if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                    {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                    {% endif %}
                    break mainLoop;
                }

                if(scoreLeft < scoreRight){
                    if(scoreLeft >= MAX_SCORE){
                        {% if DEBUG -%}System.out.println("MSG=MAX_SCORE left " + scoreLeft + " and right " + scoreRight + " are >= " + MAX_SCORE);
                        {% endif %}

                        break mainLoop;
                    }

                    {% for side in ["Left", "Right"] %}
                    {% if DEBUG -%}
                    System.out.println("MSG={{ side }}, MODE={{ side }}, score " + score + " resume at POS=" + xy{{side}} + " last dir " + lastDirection{{side}} + " ctr{{side}}=" + ctr{{side}});
                    if(withReturn){System.out.println("SCORE{{side}}=" + score{{side}});}
                    {% endif %}

                    
                    modeSplitGo{{side}}: {
                    /// If we can move without obstacle, we are free !
                    {% if DEBUG -%}System.out.println("We want to go from " + loc{{side}} + " to " + locEnd + " -> " + loc{{side}}.directionTo(locEnd));
                    {% endif %}
                    if(ctr{{side}} <= 0){ {# Avoid cycling same direction #}
                        switch (loc{{side}}.directionTo(locEnd)){
                            {% for dir in dirs -%}
                            case {{ dir }}:
                                xyTmp = xy{{side}} + {{dirsShift60xy[dir]}};
                                if(mapCosts[xyTmp] < cost_max_per_cell && --smooth{{side}} <= 0){
                                    xy = xyTmp;

                                    mapResult[xyTmp] = {{dirsOrdsOpposite[dir]}};
                                    xyLastWallLeave = xyTmp;
                                    {% if DEBUG -%}System.out.println("MODE=FREE, POS=" + xy + ", DIR={{dir}}, RESULT=FREE");
                                    {% endif %}

                                    loc = loc{{side}}.add(Direction.{{dir}});
                                    score = score{{side}} + mapCosts[xy];
                                    break modeSplit;
                                }
                                break;
                            {% endfor %}

                            case CENTER:
                                {% if DEBUG -%}System.out.println("MSG=Destination reached for side {{side}}");
                                {% endif %}

                                break mainLoop;
                        }
                    }

                    //TODO: Ces 2 la peuvent se grouper ?
                    /// Otherwise, we check by turning progressively until we found a nice space
                    switch (lastDirection{{side}}){
                        {% for dir in dirs -%}
                        case {{ dir }}:
                            {% for i in range(-2, 6)-%}
                            {% set dirTesting = rotate(dir, side, i) -%}
                            if(!onTheMap(loc{{side}}.add(Direction.{{dirTesting}}))) {
                                {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy + ", DIR={{dirTesting}}, RESULT=BORDER");
                                {% endif %}

                                score{{side}} = MAX_SCORE;
                                break modeSplitGo{{side}};
                            }

                            xyTmp = xy{{side}} + {{dirsShift60xy[dirTesting]}};
                            if(mapCosts[xyTmp] < cost_max_per_cell){
                                {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy{{side}} + ", DIR={{dirTesting}}, RESULT=OK");
                                {% endif %}


                                xy{{side}} = xyTmp;
                                ctr{{side}} += {{i}};
                                mapResult[xyTmp] = {{dirsOrdsOpposite[dirTesting]}};

                                loc{{side}} = loc{{side}}.add(Direction.{{dirTesting}});
                                score{{side}} += mapCosts[xyTmp];
                                lastDirection{{side}} = Direction.{{ dirTesting }};
                                break modeSplitGo{{side}};
                            }
                            {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy{{side}} + ", DIR={{dirTesting}}, RESULT=WALL");
                            {% endif %}

                            {% endfor -%}

                            {{ impossible(MSG="Can't find solution for side " + side + " and previous dir " + dir) }}
                        {% endfor %}

                        case CENTER:
                            {{ impossible(MSG="previous dir is center") }}
                    }
                    } // End modeSplitGo{{side}}

                    {# for side #}
                    {% if side == "Left" %}
                }else{
                    {% if DEBUG -%}System.out.println("MSG=scoreLeft >= scoreRight");
                    {% endif %}

                    
                            {% endif %}


                    {# Will generate the code for right here #}
                    {% endfor %}
                }

            }// End main for loop
        } // End mainLoopLabel

        if(!withReturn){
            System.out.println("===Pathfinding report : Backtracking===");
            System.out.println("Iterations normal : " + iterationsNormal);
            System.out.println("Iterations split  : " + iterationsSplit);
            System.out.println("Bytecode used     : " + (startRemainingBytecode - {{getBytecodeRemaining}}));
            System.out.println("");

            {% if DEBUG -%}System.out.println("MSG=no return");
            {% endif %}

            BugNav.mapResult = mapResult;
            return;
        }

        {% if DEBUG -%}System.out.println("Return mode");
        {% endif %}

        /// Now, we want to make the path in reverse to optimize it
        // We take by priority :
        // 1) xyLastWallLeave
        // 2) Best beetween xyLeft and xyRight
        // 3) xy

        int xyReturn;
        if(xyLastWallLeave != -1){
            xyReturn = xyLastWallLeave; // 1)
            {% if DEBUG -%}System.out.println("POS=" + xy + ", RESULT=RETURN = last wall leave");
            {% endif %}

        }else{
            {% if DEBUG -%}System.out.println("xyLastWallLeave is " + xyLastWallLeave + " trying other values for xyReturn");
            {% endif %}
            if(locLeft == null){
                {% if DEBUG -%}System.out.println("locLeft is null, returning xyRight");
                {% endif %}
                xyReturn = xyRight;

            }else{
                if(locRight == null){
                    {% if DEBUG -%}System.out.println("locRight is null, returning xyLeft");
                    {% endif %}
                    xyReturn = xyLeft;

                }else{
                    if(locEnd.distanceSquaredTo(locLeft) < locEnd.distanceSquaredTo(locRight)){ // 2)
                        xyReturn = xyLeft;
                        {% if DEBUG -%}System.out.println("locLeft is closer to end, returning xyLeft");
                        {% endif %}


                    }else{
                        xyReturn = xyRight;
                        {% if DEBUG -%}System.out.println("locRight is closer to end, returning xyRight");
                        {% endif %}
                    }
                }
            }

            // 3)
            if(xyReturn == -1){
                {% if DEBUG -%}System.out.println("xyReturn is -1, returning xy");
                {% endif %}

                xyReturn = xy;
            }

        }

        if(xyReturn == -1){
            {{ impossible(MSG="xyReturn is -1") }}
        }

        loc = new MapLocation(xyReturn % 60, xyReturn / 60);
        mode = "BACK";
        int returnDirection = mapResult[xyReturn];
        int iterationsReturn = 0;
        backtrackingLoop:
        for(;;){
            iterationsReturn++;
            if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                {% endif %}
                break backtrackingLoop;
            }


            {% if DEBUG -%}System.out.println("MODE=BACK, I am at: POS=" + xyReturn + " " + loc +", returnDirection is " + returnDirection);
            {% endif %}

            {# Check if the outward path diverges from the return path -#}
            switch(loc.directionTo(startLoc)){
                {% for dir in dirs -%}
                case {{dir}}:
                    if({{dirsOrds[dir]}} != returnDirection && mapCosts[xyReturn + {{dirsShift60xy[dir]}}] < cost_max_per_cell){
                        {% if DEBUG -%}System.out.println("MODE=BACK, POS=" + xyReturn + ", DIR={{dir}}, RESULT=DIVERGE from return path");
                        {% endif %}
                        loc = loc.add(Direction.{{dir}});     
                        break backtrackingLoop;
                    }else{
                        {% if DEBUG -%}System.out.println("MODE=BACK, POS=" + xyReturn + ", DIR={{dir}}, RESULT=WALL");
                        {% endif %}
                    }
                    break;
                {% endfor %}

                case CENTER:
                    {% if DEBUG -%}System.out.println("MSG=Destination reached");
                    {% endif %}
                    BugNav.mapResult = mapResult;
                    return;
            }

            {# Go up one move -#}
            switch(returnDirection){
                {% for dir in dirs -%}
                case {{dirsOrds[dir]}}: // {{dir}}
                    {% if DEBUG -%}System.out.println("MODE=BACK, POS=" + xyReturn + " " + loc +", DIR={{dir}}");
                    {% endif %}

                    xyReturn += {{dirsShift60xy[dir]}};
                    loc = loc.add(Direction.{{dir}});
                    returnDirection = mapResult[xyReturn];
                    mapResult[xyReturn] = {{dirsOrdsOpposite[dir]}};
                    break;
                {% endfor %}
            }
        }// End backtrackingLoop

        System.out.println("===Pathfinding report : Normal===");
        System.out.println("Iterations normal : " + iterationsNormal);
        System.out.println("Iterations split  : " + iterationsSplit);
        System.out.println("Iterations return : " + iterationsReturn);
        System.out.println("Bytecode used     : " + (startRemainingBytecode - {{getBytecodeRemaining}}));
        System.out.println("");

        generatePathTo(
            loc, startLoc, 
            mapCosts, mapResult, MAX_SCORE, {#With return#} false, 
            cost_max_per_cell, maxBytecodeUsed
        );
    }

    public static char[] generateEmptyMapCosts(){
        return "{%for y in range(60)-%}{% for x in range(60)-%}{%if x % 2 == 0 and y % 2 == 0%}{{intToChar(SCORE_CELL_IF_DIG)}}{%else%}{{intToChar(SCORE_CELL_PASSABLE)}}{%endif%}{%endfor%}{%endfor%}".toCharArray();
    }

    public static char[] getMap3600(){
        return "{%for x in range(3600)%}\u0000{%endfor%}".toCharArray();
    }
}
