// Destination: Utils/BugNavLmx.java

{# Scores pour franchir une cellule-#}
{% set SCORE_CELL_PASSABLE  =    1000 %}
{% set SCORE_CELL_IF_DIG    =    1100 %}
{% set SCORE_CELL_WALL      =   32000 %}
{% set SCORE_CELL_BORDER    =   32000 %}

{# Parametres pour la génération du code -#}
{% set DEBUG = false %}
{% set BATTLECODE = true %}
{% set MAX_DEBUG_ROUND = 200 %}
{% set DOT_DEBUG_LEVEL = 2%} {# Level of debug for battlecode0: None, 1: Only reverse path, 2: All -#}
{% set colorLeft = "173, 216, 230" %}
{% set colorRight = "255, 228, 181" %}
{% set getBytecodeRemaining = "Clock.getBytecodesLeft()" if BATTLECODE else "1" %}

{# Fonctions utilitaires -#}
{% set getRound = "rc.getRoundNum()" if BATTLECODE else "0" %}
{% macro impossible(MSG) -%}throw new java.lang.Error("ERR Pathfinding: {{MSG}}");{%- endmacro %}
{% set maxIndex = 0b10000001000000 + 62 + (62 * 2**7)%}

{# Imports -#}
{% if BATTLECODE %}
package current.Utils;
import battlecode.common.*;
import current.Robots.Robot;

{% else -%}
package Bugnav;
import Bugnav.MapLocation;
import Bugnav.Direction;
{% endif -%}

//@formatter:off

{# Directions -#}
{% set dirs = ["NORTH","NORTHEAST","EAST","SOUTHEAST","SOUTH","SOUTHWEST","WEST","NORTHWEST"] %}
{% set dirsPriority = {
        'NORTH': ['NORTH', 'NORTHEAST', 'NORTHWEST', 'EAST', 'WEST', 'SOUTH', 'SOUTHEAST', 'SOUTHWEST'],
        'NORTHEAST': ['NORTHEAST', 'EAST', 'NORTH', 'NORTHWEST', 'SOUTHEAST', 'SOUTH', 'WEST', 'SOUTHWEST'],
        'EAST': ['EAST', 'NORTHEAST', 'SOUTHEAST', 'NORTH', 'SOUTH', 'WEST', 'NORTHWEST', 'SOUTHWEST'],
        'SOUTHEAST': ['SOUTHEAST', 'EAST', 'SOUTH', 'NORTHEAST', 'SOUTHWEST', 'NORTH', 'WEST', 'NORTHWEST'],
        'SOUTH': ['SOUTH', 'SOUTHEAST', 'SOUTHWEST', 'EAST', 'WEST', 'NORTH', 'NORTHEAST', 'NORTHWEST'],
        'SOUTHWEST': ['SOUTHWEST', 'SOUTH', 'WEST', 'NORTHWEST', 'SOUTHEAST', 'EAST', 'NORTH', 'NORTHEAST'],
        'WEST': ['WEST', 'WEST', 'NORTHWEST', 'SOUTHWEST', 'NORTH', 'SOUTH', 'EAST', 'NORTHEAST', 'SOUTHEAST'],
        'NORTHWEST': ['NORTHWEST', 'NORTH', 'WEST', 'NORTHEAST', 'SOUTHWEST', 'EAST', 'SOUTH', 'SOUTHEAST']
    }
%}



public class {{ className }} {
    // Constants
    public static int SCORE_CELL_WALL = {{ SCORE_CELL_WALL }}; // Should not exceed 8 bits int (If added to anything else, to not overflow)
    public static int SCORE_CELL_IF_DIG = {{ SCORE_CELL_IF_DIG }};
    public static int SCORE_CELL_PASSABLE = {{ SCORE_CELL_PASSABLE }};
    public static int SCORE_CELL_BORDER = {{ SCORE_CELL_BORDER }};

    // Attributs for caching
    public static int timeBeforeRefresh = 0;
    public static MapLocation lastDestination;

    // Used for REVERSEtracking
    public static int resultCode = 0; // 1 : Ok, -1: Not enought bytecode
    public static String mode = "DEFAULT";
    public static int xyLastWallHit = -1;
    public static int xyLastWallLeave = -1;

    // Used for pathfinding
    public static char[] mapResult = getMap7B();
    public static char[] mapCosts = generateEmptyMapCosts7B();
    public static char[] mapDirections = Bugnav.MapDirections.mapDirections;

    // Utils 
    public static int[] dirsShift7Bxy =  new int[]{ {%for dir in dirs%}{{dirsShift7Bxy[dir]}}, {%endfor%} };
    public static char[] dirsOrdsOpposite = "{%for dir in dirs%}{{intToChar(dirsOrdsOpposite[dir])}}{%endfor%}".toCharArray();

    // Directions
    public static final Direction[] DIRECTIONS = {
            Direction.NORTH,
            Direction.NORTHEAST,
            Direction.EAST,
            Direction.SOUTHEAST,
            Direction.SOUTH,
            Direction.SOUTHWEST,
            Direction.WEST,
            Direction.NORTHWEST,
            Direction.CENTER
    };

    // Add score 3x3
    public static void set3x3Score(MapLocation loc, char score){
        int xy = {{ encodeCellPathfinding("loc.x", "loc.y") }};
        {% for dir in dirs -%}
            mapCosts[xy + {{dirsShift7Bxy[dir]}}] = score;
        {% endfor %}
    }

    // Add border to mapCosts
    public static void init(int width, int height){
        setWidth(width);
        setHeight(height);
        mapCosts[{{encodeCellPathfinding("width", "height")}}] = {{SCORE_CELL_BORDER}};
    }

    public static void setWidth(int width){
        switch(width){
            {% for w in range(20, 61)%} {# w is in [20, 60], so iter to 61#}
            case {{w}}:
                {% for y in range(0, 60)%} {# y is in [0, 59], so iter to 60#}
                mapCosts[{{encodeCellPathfinding(w, y)}}] = {{SCORE_CELL_BORDER}};
                {% endfor%}
                break;
            {% endfor %}
            default:
                throw new IllegalArgumentException("Width " + width + " is not supported, should be between 20 and 60");
        }
    }

    public static void setHeight(int height){
        switch(height){
            {% for h in range(20, 61)%}
            case {{h}}:
                {% for x in range(0, 60)%}
                mapCosts[{{encodeCellPathfinding(x, h)}}] = {{SCORE_CELL_BORDER}};
                {% endfor%}
                break;
            {% endfor %}
            default:
                throw new IllegalArgumentException("Height " + height + " is not supported, should be between 20 and 60");
        }
    }

    // Easier to use pathTo
    public static Direction pathTo(
        MapLocation startLoc, MapLocation endLoc,
        int MAX_SCORE, int cost_max_per_cell, int maxBytecodeUsed
    ){% if BATTLECODE %} throws GameActionException {% endif -%} {
        
        // cost_max_per_cell should be lower than SCORE_CELL_WALL
        if(cost_max_per_cell > {{SCORE_CELL_WALL}}){
            {{ impossible(MSG="cost_max_per_cell is greater than SCORE_CELL_WALL {{SCORE_CELL_WALL}}") }}
        }

        // Debug message
        {% if BATTLECODE -%}RobotController rc = Robot.rc;{% endif -%}
        if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
            System.out.println("Start Pathfinding from " + startLoc + " to " + endLoc);
        }
        

        // Initialize variables
        mode = "DEFAULT";
        int startXY = {{ encodeCellPathfinding("startLoc.x", "startLoc.y") }};
        Direction dir = DIRECTIONS[mapResult[startXY]];

        // Check if we can reuse previous path
        if(false && timeBeforeRefresh > 0 && lastDestination.equals(endLoc)){
            if(dir != Direction.CENTER){
                if({{getRound}} < {{MAX_DEBUG_ROUND}}){System.out.println("Pathfinding: Reuse previous path -> " + dir);}
                timeBeforeRefresh -= 3;
                return dir;
            }
        }

        // Generate path
        resultCode = generatePathTo(startXY, {{ encodeCellPathfinding("endLoc.x", "endLoc.y") }}, MAX_SCORE, true, cost_max_per_cell, maxBytecodeUsed);
        dir = DIRECTIONS[mapResult[startXY]];
        {% if DEBUG -%}System.out.println("Get result of pathfinding: DIRECTIONS[mapResult[startXY]]=DIRECTIONS[" + (int)mapResult[startXY] + "] with startXY=" + startXY);{% endif -%}

        // Check result validity
        if(resultCode < 0){
            if({{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                System.out.println("Pathfinding: Warning return code : " + resultCode + " : " + dir);
            }    
            timeBeforeRefresh = 0; // Don't save query result
            return null;

        }else{
            if({{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                System.out.println("Pathfinding: SUCCESS -> " + dir);
            }
            timeBeforeRefresh = 3; // Save query result for 3 rounds
            lastDestination = endLoc;
        }

        // Return result
        return dir;
    }


    private static int generatePathTo(
        int xyStart /* startloc */, int xyEnd /* endloc */, 
        int MAX_SCORE, boolean withReturn, 
        int cost_max_per_cell, int maxBytecodeUsed){% if BATTLECODE %} throws GameActionException {% endif -%}{

        {% if BATTLECODE -%}RobotController rc = Robot.rc;{% endif -%}

        // Initialize variables
        int xy = xyStart; // {{ encodeCellPathfinding("startLoc.x", "startLoc.y") }};
        int xyEndDir = {{ addDelimiter("xyEnd") }};
        int xyTmp;


        // Initialize split mode variables
        int xyLeft = -1;
        int xyRight = -1;
        int ctrLeft;
        int ctrRight;
        int smoothLeft;
        int smoothRight;


        // Initialize result variables
        int score = 0;
        xyLastWallHit = -1;
        xyLastWallLeave = -1;
        mapResult = getMap7B();
        mapResult[xy] = {{dirsOrds["CENTER"]}};


        // Reduce bytecode by moving variables in local scope
        char[] mapCosts = {{className}}.mapCosts;
        Direction[] DIRECTIONS = {{className}}.DIRECTIONS;
        char[] mapDirections = {{className}}.mapDirections;


        // Bytecode and benchmark variables
        int iterationsSplit = 0;
        int iterationsNormal = 0;
        int startRemainingBytecode = {% if BATTLECODE %} Clock.getBytecodesLeft() {% else %} 0 {% endif -%};
        int stopBellowBytecodeRemaining;
        if(withReturn){
            stopBellowBytecodeRemaining = {% if BATTLECODE %} Clock.getBytecodesLeft() - maxBytecodeUsed / 3 {% else %} 0 {% endif -%};
        }else{
            stopBellowBytecodeRemaining = {% if BATTLECODE %} Clock.getBytecodesLeft() - maxBytecodeUsed {% else %} 0 {% endif -%};
        }



        mainLoop: // We exit the loop when direction to target is Direction.CENTER
        for(;;) {

            /////////////////////////////////// Default mode ////////////////////////////////
            /// we just go to the direction. If wall, we check if better left or right and enter left or right mode then
            modeDefault:
            for (;;) {
                iterationsNormal++;

                {# Debug messages -#}
                {% if DEBUG -%}
                    System.out.println("MODE=" + mode + ", resume at POS=" + xy + " want to go to " + xyEnd + " -> " + DIRECTIONS[mapDirections[xyEndDir - xy]]);
                    if(withReturn){System.out.println("SCORE=" + score);}
                {% endif -%}
                {% if BATTLECODE and DOT_DEBUG_LEVEL >= 2 -%}
                    if(withReturn){  rc.setIndicatorDot({{xyToMapLocation("xy")}}, 0, 10, 10); // Blue
                    }else{           rc.setIndicatorDot({{xyToMapLocation("xy")}}, 206, 174, 243); // Violet
                    }
                {% endif -%}

                {# Check if we have enough bytecode remaining -#}
                if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                    {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                    {% endif -%}
                    break mainLoop;
                }

                {# Check direction to target -#}
                switch (mapDirections[xyEndDir - xy]) {
                    {% for dir in dirsWhitoutCenter -%}
                    case {{dirsOrds[dir]}}:

                        {# Check if direction is on the map -#}
                        {#if(!onTheMap(loc.add(Direction.{{dir}}))){
                            {{ impossible(MSG="Reach a border when direction to cell on map") }}
                        }-#}

                        {# Check if we can move to this cell -#}
                        xyTmp = xy + {{dirsShift7Bxy[dir]}};
                        if(mapCosts[xyTmp] > cost_max_per_cell){
                            {% if DEBUG -%}System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=WALL score: " + (int)mapCosts[xyTmp] + " for cell " + xyTmp);
                            {% endif -%}

                            xyLastWallHit = xyTmp;
                            break modeDefault;
                        }

                        {# Move to this direction -#}
                        {% if DEBUG -%}
                        System.out.println("POS=" + xy + ", DIR={{dir}}, RESULT=OK score: " + (int)mapCosts[xyTmp]);
                        System.out.println("Writte " + {{dirsOrdsOpposite[dir]}} + "dursOrdsOpposite[{{dir}}] = {{dirsOpposite[dir]}} at " + (int)xyTmp);
                        {% endif -%}
                        xy = xyTmp;
                        mapResult[xyTmp] = {{dirsOrdsOpposite[dir]}};
                        break;
                    {%endfor %}

                    {# If direction to target is center, we have reached our destination -#}
                    case 8: // CENTER
                        {% if DEBUG -%}System.out.println("MSG=CENTER from mainLopp");
                        {% endif -%}
                        break mainLoop;

                    default:
                        {{ impossible(MSG="Normal mode: Invalid direction : \" + DIRECTIONS[mapDirections[xyEndDir - xy]] + \" ") }}
                }
        
                {# We are on the next cell, update score -#}
                score += mapCosts[xy];
                if(score >= MAX_SCORE){ // We haven't enough score to reach our destination
                    {% if DEBUG -%}System.out.println("MSG=MAX_SCORE " + score + " >= " + MAX_SCORE);
                    {% endif -%}
                    break mainLoop;
                }
            }


            /// ///////////////////// Init split mode /////////////////////
            {% if DEBUG -%}System.out.println("MSG=init split mode");
            {% endif -%}

            {# Initialize split mode variables -#}
            xyLeft = xy;
            xyRight = xy;
            smoothLeft = 2;
            smoothRight = 2;
            int scoreLeft = 0;
            int scoreRight = 0;
            char lastDirectionLeft;
            char lastDirectionRight;

            // Direction to target is an obstacle, we need to init left and right side for exploration
            switch (mapDirections[xyEndDir - xy]) {

                {% for dir in dirs -%}
                case {{dirsOrds[dir]}}:
                
                    {% for side in ["Left", "Right"] -%}

                    initSide{{side}}:{
                    {% for i in range(1, 7) -%}
                    {# Test a direction by progressively turning, we stop when we find a cell that is not a wall -#}
                    {% set dirTest = rotate(dir, side, i) -%}
                    if(mapCosts[xy + {{dirsShift7Bxy[dirTest]}}] <= cost_max_per_cell) {

                        {# We found a cell that is not a wall, we can init the side -#}
                        ctr{{side}} = {{i}};
                        xy{{side}} = xy + {{dirsShift7Bxy[dirTest]}};
                        lastDirection{{side}} = {{dirsOrds[dirTest]}};
                        mapResult[xy{{side}}] = {{dirsOrdsOpposite[dirTest]}};

                        {# Debug messages -#}
                        {% if DEBUG -%}
                            System.out.println("POS=" + xy + ", DIR={{dirTest}}, RESULT=OK");
                            System.out.println("MSG={{side}} init to " + xy{{side}});
                        {% endif -%}
                        break initSide{{side}};
                    }

                    {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy + ", DIR={{dirTest}}, RESULT=WALL");
                    {% endif -%}

                    {% endfor -%} {# for i in range(1, 7) -#}

                    {{ impossible(MSG="impossible to init split mode (All directions are blocked)") }}
                    } // End initSide{{side}}
                    
                    {% endfor %} {# for side in ["Left", "Right"] -#}
                    break;

                {% endfor %}     {# for dir in dirs -#}

                default:
                    {{ impossible(MSG="Initsplit: Invalid direction to target. : \" + DIRECTIONS[mapDirections[xyEndDir - xy]] + \" ") }}
            }

            
            // TODO: Add default score for left / right depending situation
            scoreLeft = score + mapCosts[xyLeft];
            scoreRight = score + mapCosts[xyRight];

            /////////////////////////////////// Split mode ////////////////////////////////
            /// The direction we want to take is blocked, we will split bugnav to right and left
            /// We advance side with the lowest score, with score = distance for example
            /// When dir is not blocked anymore, we go REVERSE to modeDefault

            modeSplit:
            for (;;) {
                iterationsSplit++;
                if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                    {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                    {% endif -%}
                    break mainLoop;
                }

                if(scoreLeft < scoreRight + SCORE_CELL_PASSABLE * 4){ // Little advantage on right
                    if(scoreLeft >= MAX_SCORE){
                        {% if DEBUG -%}System.out.println("MSG=MAX_SCORE left " + scoreLeft + " and right " + scoreRight + " are >= " + MAX_SCORE);
                        {% endif -%}

                        break mainLoop;
                    }

                    {% for side in ["Left", "Right"] %}
                    {% if DEBUG -%}
                    System.out.println("MSG={{ side }}, MODE={{ side }}, score " + score + " resume at POS=" + xy{{side}} + " last dir " + DIRECTIONS[lastDirection{{side}}] + " ctr{{side}}=" + ctr{{side}});
                    if(withReturn){System.out.println("SCORE{{side}}=" + score{{side}});}
                    {% endif -%}

                    
                    modeSplitGo{{side}}: {
                    // debug messages
                    {% if DEBUG -%}System.out.println("We want to go from " + xy{{side}} + " to " + xyEnd + " -> " + DIRECTIONS[mapDirections[xyEndDir - xy{{side}} ]]);
                    {% endif -%}
                    {% if BATTLECODE and DOT_DEBUG_LEVEL >= 2 %}
                        int locIndicator = xy{{side}}; {# Can't mixe java variable conditonned to jinja variable :sweat: -#}
                        rc.setIndicatorDot({{xyToMapLocation("locIndicator")}}, {{ (colorLeft if side == "Left" else colorRight) }});
                    {% endif%}

                    // We dont want to rush destination if we haven't turn enough
                    if(ctr{{side}} <= 0){ {# Avoid cycling same direction -#}
                        switch (mapDirections[xyEndDir - xy{{side}}]){
                            {% for dir in dirs -%}

                            case {{ dirsOrds[dir] }}:

                                {# Check if we can move to this cell -#}
                                xyTmp = xy{{side}} + {{dirsShift7Bxy[dir]}};
                                if(mapCosts[xyTmp] <= cost_max_per_cell && --smooth{{side}} <= 0){

                                    xy = xyTmp;
                                    mapResult[xyTmp] = {{dirsOrdsOpposite[dir]}};
                                    score = score{{side}} + mapCosts[xy];
                                    xyLastWallLeave = xyTmp;

                                    {% if DEBUG -%}
                                    System.out.println("MAPRESULT[" + xyTmp + "] = " + DIRECTIONS[{{dirsOrdsOpposite[dir]}}]);
                                    System.out.println("MODE=FREE, POS=" + xy + ", DIR={{dir}}, RESULT=FREE");
                                    {% endif -%}
                                    break modeSplit;
                                }
                                break;
                            {% endfor %}

                            case 8:
                                {% if DEBUG -%}System.out.println("MSG=Destination reached for side {{side}}");
                                {% endif -%}

                                break mainLoop;

                            default:
                                {{ impossible(MSG="Split mode:" + side + " Invalid direction to target. : \" + (int)mapDirections[xyEndDir - xy"+ side + "] + \" ") }}
                        }
                    }

                    /// Otherwise, we check by turning progressively until we found the next free cell next to the wall
                    switch (lastDirection{{side}}){
                        {% for dir in dirs -%}
                        case {{ dirsOrds[dir] }}:
                            {% for i in range(-2, 6)-%}
                            {% set dirTesting = rotate(dir, side, i) -%}
                            xyTmp = xy{{side}} + {{dirsShift7Bxy[dirTesting]}};

                            {# Check if the cell is a border, if so, stop exploring this side -#}
                            if(mapCosts[xyTmp] == {{SCORE_CELL_BORDER}}) {
                                {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy + ", DIR={{dirTesting}}, RESULT=BORDER");
                                {% endif -%}

                                score{{side}} = MAX_SCORE;
                                break modeSplitGo{{side}};
                            }

                            {# Check if we can move to this cell -#}
                            if(mapCosts[xyTmp] <= cost_max_per_cell){
                                {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy{{side}} + ", DIR={{dirTesting}}, RESULT=OK");
                                {% endif -%}


                                xy{{side}} = xyTmp;
                                ctr{{side}} += {{i}};
                                mapResult[xyTmp] = {{dirsOrdsOpposite[dirTesting]}};
                                {% if DEBUG -%}System.out.println("MAPRESULT[" + xyTmp + "] = " + DIRECTIONS[{{dirsOrdsOpposite[dirTesting]}}]);
                                {% endif -%}

                                score{{side}} += mapCosts[xyTmp];
                                lastDirection{{side}} = {{ dirsOrds[dirTesting] }};
                                break modeSplitGo{{side}};
                            }
                            {% if DEBUG -%}System.out.println("MODE={{ side }}, POS=" + xy{{side}} + ", DIR={{dirTesting}}, RESULT=WALL");
                            {% endif -%}

                            {% endfor -%}

                            {{ impossible(MSG="Can't find solution for side " + side + " and previous dir " + dir) }}
                        {% endfor %}

                        case 8: // Center
                            {{ impossible(MSG="previous dir is center") }}

                        default:
                            {{ impossible(MSG="Split mode:" + side + " Invalid last direction.") }}
                    }
                    } // End modeSplitGo{{side}}

                    {# for side -#}
                    {% if side == "Left" %}{# scoreRight < scoreLeft + SCORE_CELL_PASSABLE * 4 -#}
                }else{
                    {% if DEBUG -%}System.out.println("MSG=scoreLeft >= scoreRight");
                    {% endif -%}

                    
                    {% endif -%}


                            {# Will generate the code for right split mode here -#}


                    {% endfor %}
                }

            }// End main for loop
        } // End mainLoopLabel

        if(!withReturn){
            if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
                System.out.println("===Pathfinding report : REVERSE ===");
                System.out.println("Iterations normal : " + iterationsNormal);
                System.out.println("Iterations split  : " + iterationsSplit);
                System.out.println("Bytecode used     : " + (startRemainingBytecode - {{getBytecodeRemaining}}));
            }

            {% if DEBUG -%}System.out.println("MSG=no return");
            {% endif -%}

            {{ className }}.mapResult = mapResult;
            if(xy != xyEnd){ {# Reversemode: We haven't reached the start of pathfinding -#}
                return -1;
            }
            return 1;
        }

        {% if DEBUG -%}System.out.println("Return mode");
        {% endif -%}

        /// Now, we want to make the path in reverse to optimize it
        // We take by priority :
        // 1) xyLastWallLeave
        // 2) Best beetween xyLeft and xyRight
        // 3) xy

        int xyReturn;
        if(xyLastWallLeave != -1){
            xyReturn = xyLastWallLeave; // 1)
            {% if DEBUG -%}System.out.println("POS=" + xy + ", RESULT=RETURN = last wall leave");
            {% endif -%}

        }else{
            {% if DEBUG -%}System.out.println("xyLastWallLeave is " + xyLastWallLeave + " trying other values for xyReturn");
            {% endif -%}
            if(xyLeft == -1){
                {% if DEBUG -%}System.out.println("locLeft is null, returning xyRight");
                {% endif -%}
                xyReturn = xyRight;

            }else{
                if(xyRight == -1){
                    {% if DEBUG -%}System.out.println("locRight is null, returning xyLeft");
                    {% endif -%}
                    xyReturn = xyLeft;

                }else{
                    MapLocation locEnd = {{ xyToMapLocation("xyEnd") }};
                    MapLocation locLeft = {{ xyToMapLocation("xyLeft") }};
                    MapLocation locRight = {{ xyToMapLocation("xyRight") }};
                    if(locEnd.distanceSquaredTo(locLeft) < locEnd.distanceSquaredTo(locRight)){ // 2)
                        xyReturn = xyLeft;
                        {% if DEBUG -%}System.out.println("locLeft is closer to end, returning xyLeft");
                        {% endif -%}


                    }else{
                        xyReturn = xyRight;
                        {% if DEBUG -%}System.out.println("locRight is closer to end, returning xyRight");
                        {% endif -%}
                    }
                }
            }

            // 3)
            if(xyReturn == -1){
                {% if DEBUG -%}System.out.println("xyReturn is -1, returning xy");
                {% endif -%}

                xyReturn = xy;
            }

        }

        if(xyReturn == -1){
            {{ impossible(MSG="xyReturn is -1") }}
        }

        mode = "REVERSE";
        int iterationsReturn = 0;
        int xyStartDir = {{ addDelimiter("xyStart") }};
        
        ReverseLoop:
        for(;;){
            iterationsReturn++;

            // Check bytecode limits
            if({{getBytecodeRemaining}} < stopBellowBytecodeRemaining){
                {% if DEBUG -%}System.out.println("MSG=not enough bytecode remaining");
                {% endif -%}
                break ReverseLoop;
            }


            // Debug
            int returnDirection = mapResult[xyReturn];
            {% if DEBUG -%}System.out.println("MODE=REVERSE, I am at: POS=" + xyReturn + " returnDirection is " + DIRECTIONS[returnDirection]);
            {% endif -%}
            {% if BATTLECODE and DOT_DEBUG_LEVEL >= 1 %}
            rc.setIndicatorDot({{xyToMapLocation("xyReturn")}}, 206, 174, 243);
            {% endif -%}


            {# Check if the reverse path diverges from the direction to start -#}
            switch(mapDirections[xyStartDir - xyReturn]){
                {% for dir in dirs -%}
                case {{dirsOrds[dir]}}:
                    if({{dirsOrds[dir]}} != returnDirection && mapCosts[xyReturn + {{dirsShift7Bxy[dir]}}] <= cost_max_per_cell){
                        {% if DEBUG -%}System.out.println("MODE=REVERSE, POS=" + xyReturn + ", DIR={{dir}}, RESULT=DIVERGE from return path");
                        {% endif -%}
                        xyReturn += {{dirsShift7Bxy[dir]}};
                        break ReverseLoop;
                    }else{
                        {% if DEBUG -%}System.out.println("MODE=REVERSE, POS=" + xyReturn + ", DIR={{dir}}, RESULT=WALL");
                        {% endif -%}
                    }
                    break;
                {% endfor %}

                case 8: // Center
                    if({{getRound}} < {{MAX_DEBUG_ROUND}}){System.out.println("MSG=Destination reached directly by reverse path");}
                    if(returnDirection == 8){
                        return 1;
                    }
                    xyReturn += dirsShift7Bxy[returnDirection];
                    mapResult[xyReturn] = dirsOrdsOpposite[returnDirection];
                    return 1;

                default:
                    {{ impossible(MSG="REVERSE mode: Invalid direction to start. : \" + (int)mapDirections[xyStartDir - xyReturn] + \" ") }}
            }

            {# Go up one move and writte direction -#}
            // TODO: Check this good ?
            if(returnDirection == 8){
                return 1;
            }
            xyReturn += dirsShift7Bxy[returnDirection];
            mapResult[xyReturn] = dirsOrdsOpposite[returnDirection];
        }// End ReverseLoop

        if( {{ getRound }} < {{ MAX_DEBUG_ROUND }}){
            System.out.println("===Pathfinding report : Normal===");
            System.out.println("Iterations normal : " + iterationsNormal);
            System.out.println("Iterations split  : " + iterationsSplit);
            System.out.println("Iterations return : " + iterationsReturn);
            System.out.println("Bytecode used     : " + (startRemainingBytecode - {{getBytecodeRemaining}}));
            System.out.println("");
        }

        return generatePathTo(
            xyReturn, xyStart, 
            MAX_SCORE, false /* withReturn */, 
            cost_max_per_cell, maxBytecodeUsed
        );
    }

    public static char[] generateEmptyMapCosts7B(){
        // generateEmptyMapCosts7B(passableValue, mod2value, borderValue, invalidValue):
        return {{ generateEmptyMapCosts7B(SCORE_CELL_PASSABLE, SCORE_CELL_PASSABLE, SCORE_CELL_BORDER, SCORE_CELL_BORDER) }};
    }

    public static char[] getMap7B(){
        return "{%for x in range(maxIndex)%}\u0000{%endfor%}".toCharArray();
    }
}
