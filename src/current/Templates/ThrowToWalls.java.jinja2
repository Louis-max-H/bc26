//  Destination: States/ThrowToWalls.java

package current.States;

import battlecode.common.*;
import current.Utils.BugNavLmx;
import current.Utils.PathFinding;

import static current.States.Code.*;

public class {{className}} extends State {

    public {{className}}(){
        this.name = "{{className}}";
    }

    @Override
    public Result run() throws GameActionException {
        if(rc.getCarrying() == null){
            return new Result(OK, "");
        }

        if(!rc.isActionReady() && !rc.canTurn()){
            return new Result(OK, "Not action ready");
        }

        if(rc.getRoundNum() - roundRatnap <= 5){
            return new Result(OK, "Too soon to throw");
        }

        int score = checkDirectionThrow(rc.getDirection());
        Direction bestDir = rc.getDirection();
        // System.out.println("CheckDirectionThrow " + rc.getDirection() + ":" + score);

        int s = checkDirectionThrow(rc.getDirection().rotateRight());
        // System.out.println("CheckDirectionThrow " + rc.getDirection().rotateRight() + ":" + s);
        if(s < score){
            score = s;
            bestDir = rc.getDirection().rotateRight();
        }

        s = checkDirectionThrow(rc.getDirection().rotateLeft());
        // System.out.println("CheckDirectionThrow " + rc.getDirection().rotateLeft() + ":" + s);
        if(s < score){
            score = s;
            bestDir = rc.getDirection().rotateLeft();
        }

        Direction d = rc.getDirection().rotateRight();
        for(int i = 0; i < 5; i++){
            d = d.rotateRight();
            s = checkDirectionThrow(d);
            // System.out.println("CheckDirectionThrow " + d + ":" + s);
            if(s < score){
                score = s;
                bestDir = d;
            }
        }

        if(score < 10){
            return playThrow(bestDir);
        }

        return new Result(OK, "Can't throw to walls s=" + score);
    };

    public static Result playThrow(Direction dir) throws GameActionException {
        // Turn in correct direction if needed
        if(rc.getDirection() != dir){
            if(rc.canTurn()){
                rc.turn(dir);
            }else{
                return new Result(ERR, "Need turn to throw to " + dir);
            }
        }

        // Update score
        int score = checkDirectionThrow(rc.getDirection());
        if(score >= 10){
            return new Result(OK, "Can't throw to walls s=" + score);
        }

        // Moving back for 1
        if(score == 1 && rc.canMove(dir.opposite())){
            lastDirection = dir.opposite();
            PathFinding.move(dir.opposite());
        }

        // Moving front to make more damage
        if(score > 1 && rc.canMove(dir)){
            lastDirection = dir;
            PathFinding.move(dir);
        }

        // can't throw ?
        if(!rc.canThrowRat()){
            return new Result(ERR, "Can't throw ???!!!");
        }

        // Add enemies rats back to the list of enemies on the map (especialy the one we are throwing)
        MapLocation enemyLoc = rc.getLocation().add(dir);
        if(score >= 2){enemyLoc = enemyLoc.add(dir);}
        if(score >= 3){enemyLoc = enemyLoc.add(dir);}
        enemiesRats.add(enemyLoc, rc.getCarrying().getID());

        rc.throwRat();
        return new Result(OK, "Enemy throw !");
    }

    public static int checkDirectionThrow(Direction dir) throws GameActionException {
        // 10: not possible (Ally)
        // 11: not possible (too narrow)
        //  0: Without moving
        //  1: Move backward
        //  2: Move direction
        //  3: Move + 2 dist in direction 
        // 12: Too far
        // 13: Out of the map
        MapLocation loc = myLoc.add(dir);
        char[] mapCosts = BugNavLmx.mapCosts;
        int xy = {{encodeCellPathfinding("myLoc.x", "myLoc.y")}};
        int SCORE_CELL_WALL = BugNavLmx.SCORE_CELL_WALL;

        switch(dir){
            {% for dir in dirsWhitoutCenter -%}
            case Direction.{{dir}}:
                if(rc.canSenseLocation(loc)){
                    if(rc.canSenseRobotAtLocation(loc)){
                        return 10;
                    }

                    if(!rc.senseMapInfo(loc).isPassable()){
                        if(rc.canMove(Direction.{{dirsOpposite[dir]}})){
                            return 1;
                        }else{
                            return 11;
                        }
                    }

                    loc = loc.add(Direction.{{dir}});
                    if(!rc.canSenseLocation(loc)){return 13;}
                    if(rc.canSenseRobotAtLocation(loc)){return 15;} // Ally
                    if(!rc.senseMapInfo(loc).isPassable()){
                        return 0;
                    }

                    loc = loc.add(Direction.{{dir}});
                    if(!rc.canSenseLocation(loc)){return 13;}
                    if(rc.canSenseRobotAtLocation(loc)){return 17;} // Ally
                    if(!rc.senseMapInfo(loc).isPassable()){
                        return 2;
                    }

                    loc = loc.add(Direction.{{dir}});
                    if(!rc.canSenseLocation(loc)){return 13;}
                    if(rc.canSenseRobotAtLocation(loc)){return 17;} // Ally
                    if(!rc.senseMapInfo(loc).isPassable()){
                        return 3;
                    }

                    return 17;
                }else{
                    if(mapCosts[xy + {{dirsShift7Bxy[dir]}}] >= SCORE_CELL_WALL){
                        if(rc.canMove(Direction.{{dirsOpposite[dir]}})){
                            return 1;
                        }else{
                            return 17;
                        }
                    }

                    if(mapCosts[xy + {{dirsShift7Bxy[dir] * 2}}] >= SCORE_CELL_WALL){
                        return 0;
                    }

                    if(mapCosts[xy + {{dirsShift7Bxy[dir] * 3}}] >= SCORE_CELL_WALL){
                        return 2;
                    }

                    if(mapCosts[xy + {{dirsShift7Bxy[dir] * 4}}] >= SCORE_CELL_WALL){
                        return 3;
                    }
                    return 12;
                }
            {% endfor -%}
            default:
                System.out.println("CheckDirectionThrow called with center.");
                return 10;
        }
    }

}
